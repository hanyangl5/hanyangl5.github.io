<?xml version='1.0' encoding='UTF-8'?>
<link rel="stylesheet" href="/github-markdown-css/github-css.css">

<meta content="text/html" charset="UTF-8">


<div class="gist">
    <style class="formula-style">
        svg.gh-md-to-html-formula {
            fill: black;
        }
    </style>
    <div class="gist-file"> <!-- This is the class that is responsible for the boxing! -->
        <div class="gist-data">
            <div class="js-gist-file-update-container js-task-list-container file-box">
                <div id="article-graphicpipeline" class="file">
                    <div id="file-docker-image-pull-md-readme" class="Box-body readme blob js-code-block-container p-5 p-xl-6"
                         style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px">
                        <article class="markdown-body entry-content container-lg" itemprop="text">
                            <h1>
<a id="user-content-图形渲染管线" class="anchor" href="#%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>图形渲染管线</h1>
<p>总结自：<a href="https://github.com/QianMo/Real-Time-Rendering-3rd-CN-Summary-Ebook">https://github.com/QianMo/Real-Time-Rendering-3rd-CN-Summary-Ebook</a></p>
<p>图形渲染管线，也叫做渲染管线，是指在给定虚拟摄像机，三维空间下的物体，光源等条件下，渲染出二维图像的过程，下图展现了使用渲染管线的步骤</p>
<p><a href="https://camo.githubusercontent.com/40be7773416d24705ddf2049159cf8f914bcbb0cf4945678647fd2de995fa0e0/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30312e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/40be7773416d24705ddf2049159cf8f914bcbb0cf4945678647fd2de995fa0e0/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30312e6a7067" alt="" data-canonical-src="http://www.realtimerendering.com/figures/thumb/RTR4.02.01.jpg" style="max-width:100%;"></a></p>
<p>在概念上可以将图形渲染管线分为如下几个阶段：</p>
<p>-application应用阶段
-geometryprocessing几何处理
-rasterization光栅化
-pixelprocessing像素处理</p>
<p><a href="https://camo.githubusercontent.com/37aa14c4e670e5209a746db2033c67d8fde2b3e120e786d801f1404b38eb389d/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30322e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/37aa14c4e670e5209a746db2033c67d8fde2b3e120e786d801f1404b38eb389d/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30322e6a7067" alt="" data-canonical-src="http://www.realtimerendering.com/figures/thumb/RTR4.02.02.jpg" style="max-width:100%;"></a></p>
<p>其中，每个阶段的处理是并行的，从前一个阶段接受数据，并传入下一个阶段</p>
<p>最慢的管线阶段决定绘制速度，即图像的更新速度，这种速度一般用FPS来表示，也就是每秒绘制的图像数量，或者用Hz来表示</p>
<hr>
<h3>
<a id="user-content-应用阶段" class="anchor" href="#%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>应用阶段</h3>
<hr>
<p>应用阶段是在CPU上运行的，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能</p>
<p>应用阶段通常实现的方法有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。</p>
<p>应用阶段结束后，几何体将以图元（renderingprimitives）的方式传给几何阶段</p>
<hr>
<h3>
<a id="user-content-几何阶段" class="anchor" href="#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>几何阶段</h3>
<p>几何阶段主要负责大部分多边形操作和顶点操作。可以将这个阶段进一步划分成如下几个阶段</p>
<p>-顶点变换
-顶点着色
-投影
-裁剪
-屏幕映射</p>
<p><a href="https://camo.githubusercontent.com/c57c6667c69851a95cb1fcd08ab35b8231da7c1092b1c2c13b66804ba6f6d0d1/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30332e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/c57c6667c69851a95cb1fcd08ab35b8231da7c1092b1c2c13b66804ba6f6d0d1/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30332e6a7067" alt="" data-canonical-src="http://www.realtimerendering.com/figures/thumb/RTR4.02.03.jpg" style="max-width:100%;"></a>
（在RTR4中，作者将前两个阶段合并成了一个阶段）</p>
<h4>
<a id="user-content-顶点变换" class="anchor" href="#%E9%A1%B6%E7%82%B9%E5%8F%98%E6%8D%A2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>顶点变换</h4>
<p>在屏幕上的显示过程中，模型通常需要变换到若干不同的空间或坐标系中。模型变换的变换对象一般是模型的顶点和法线。物体的坐标称为模型坐标。世界空间是唯一的，所有的模型经过变换后都位于同一个空间中。</p>
<p>不难理解，应该仅对相机（或者视点）可以看到的模型进行绘制。而相机在世界空间中有一个位置方向，用来放置和校准相机。</p>
<p>为了便于投影和裁剪，必须对相机和所有的模型进行视点变换。变换的目的就是要把相机放在原点，然后进行视点校准，使其朝向Z轴负方向，y轴指向上方,x轴指向右边。在视点变换后，实际位置和方向就依赖于当前的API。我们称上述空间为相机空间或者观察空间。
下图显示了视点变换对相机和模型的影响。</p>
<p><a href="https://camo.githubusercontent.com/ba6398edb8932328831b2c3abb6f7f1058f30b50a865b46efa86f2f1459e2a61/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30342e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/ba6398edb8932328831b2c3abb6f7f1058f30b50a865b46efa86f2f1459e2a61/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30342e6a7067" alt="" data-canonical-src="http://www.realtimerendering.com/figures/thumb/RTR4.02.04.jpg" style="max-width:100%;"></a></p>
<h4>
<a id="user-content-顶点着色" class="anchor" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>顶点着色</h4>
<p>为了产生逼真的场景，渲染形状和位置是远远不够的，我们需要对物体的外观进行建模。而物体经过建模，会得到对包括每个对象的材质，以及照射在对象上的任何光源的效果在内的一些描述。且光照和材质可以用任意数量的方式，从简单的颜色描述到复杂的物理描述来模拟。</p>
<p>确定材质上的光照效果的这种操作被称为着色（shading），着色过程涉及在对象上的各个点处计算着色方程（shadingequation）。通常，这些计算中的一些在几何阶段期间在模型的顶点上执行（vertexshading），而其他计算可以在每像素光栅化（per-pixelrasterization）期间执行。可以在每个顶点处存储各种材料数据，诸如点的位置，法线，颜色或计算着色方程所需的任何其它数字信息。顶点着色的结果（其可以是颜色，向量，纹理坐标或任何其他种类的阴着色数据）计算完成后，会被发送到光栅化阶段以进行插值操作。</p>
<p>通常，着色计算通常认为是在世界空间中进行的。在实践中，有时需要将相关实体（诸如相机和光源）转换到一些其它空间（诸如模型或观察空间）并在那里执行计算，也可以得到正确的结果。
这是因为如果着色过程中所有的实体变换到了相同的空间，着色计算中需要的诸如光源，相机和模型之间的相对关系是不会变的。</p>
<h4>
<a id="user-content-投影" class="anchor" href="#%E6%8A%95%E5%BD%B1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>投影</h4>
<p>在光照处理之后，渲染系统就开始进行投影操作，即将视体变换到一个对角顶点分别是(-1,1,-1)和(1,1,1)单位立方体（unitcube）内，这个单位立方体通常也被称为规范立方体（CanonicalViewVolume，CVV）。</p>
<p>目前，主要有两种投影方法，即：</p>
<p>正交投影（orthographicprojection，或称parallelprojection）</p>
<p>透视投影（perspectiveprojection）。</p>
<p><a href="https://camo.githubusercontent.com/73328a80eb1e5a2a805ab0e6d83d459e6c3081c220878110d36f131e3d431f4d/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30352e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/73328a80eb1e5a2a805ab0e6d83d459e6c3081c220878110d36f131e3d431f4d/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30352e6a7067" alt="" data-canonical-src="http://www.realtimerendering.com/figures/thumb/RTR4.02.05.jpg" style="max-width:100%;"></a></p>
<p>两种投影方式的主要异同点：</p>
<p>正交投影。正交投影的可视体通常是一个矩形，正交投影可以把这个视体变换为单位立方体。正交投影的主要特性是平行线在变换之后彼此之间仍然保持平行，这种变换是平移与缩放的组合。</p>
<p>透视投影。相比之下，透视投影比正交投影复杂一些。在这种投影中，越远离摄像机的物体，它在投影后看起来越小。更进一步来说，平行线将在地平线处会聚。透视投影的变换其实就是模拟人类感知物体的方式。</p>
<p>正交投影和透视投影都可以通过4x4的矩阵来实现，在任何一种变换之后，都可以认为模型位于归一化处理之后的设备坐标系中。</p>
<p>虽然这些矩阵变换是从一个可视体变换到另一个，但它们仍被称为投影，因为在完成显示后，Z坐标将不会再保存于的得到的投影图片中。通过这样的投影方法，就将模型从三维空间投影到了二维的空间中。</p>
<h4>
<a id="user-content-裁剪" class="anchor" href="#%E8%A3%81%E5%89%AA" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>裁剪</h4>
<p>只有当图元完全或部分存在于视体（也就是上文的规范立方体，CVV）内部的时候，才需要将其发送到光栅化阶段，这个阶段可以把这些图元在屏幕上绘制出来。</p>
<p>不难理解，一个图元相对视体内部的位置，分为三种情况：完全位于内部、完全位于外部、部分位于内部。所以就要分情况进行处理：</p>
<p>当图元完全位于视体内部，那么它可以直接进行下一个阶段。</p>
<p>当图元完全位于视体外部，不会进入下一个阶段，可直接丢弃，因为它们无需进行渲染。</p>
<p>当图元部分位于视体内部，则需要对那些部分位于视体内的图元进行裁剪处理。</p>
<p>对部分位于视体内部的图元进行裁剪操作，这就是裁剪过程存在的意义。裁剪过程见下图。</p>
<p><a href="https://camo.githubusercontent.com/b938fe4a3e600fc486f709d56ceafbf16e3e5f26a5d53e74c23de8a7e2215e05/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30362e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/b938fe4a3e600fc486f709d56ceafbf16e3e5f26a5d53e74c23de8a7e2215e05/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30362e6a7067" alt="" data-canonical-src="http://www.realtimerendering.com/figures/thumb/RTR4.02.06.jpg" style="max-width:100%;"></a></p>
<h4>
<a id="user-content-屏幕映射" class="anchor" href="#%E5%B1%8F%E5%B9%95%E6%98%A0%E5%B0%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>屏幕映射</h4>
<p>只有在视体内部经过裁剪的图元，以及之前完全位于视体内部的图元，才可以进入到屏幕映射阶段。进入到这个阶段时，坐标仍然是三维的（但显示状态在经过投影阶段后已经成了二维），每个图元的x和y坐标变换到了屏幕坐标系中，屏幕坐标系连同z坐标一起称为窗口坐标系。</p>
<p>假定在一个窗口里对场景进行绘制，窗口的最小坐标为（x1，y1），最大坐标为（x2，y2），其中x1&lt;x2，y1&lt;y2。屏幕映射首先进行平移，随后进行缩放，在映射过程中z坐标不受影响。新的x和y坐标称为屏幕坐标系，与z坐标一起（-1≦z≦1）进入光栅化阶段。</p>
<p><a href="https://camo.githubusercontent.com/735646893da15289eb3364652af44e4a47f54ab832c43e501eeba755007c1ee0/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30372e6a7067" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/735646893da15289eb3364652af44e4a47f54ab832c43e501eeba755007c1ee0/687474703a2f2f7777772e7265616c74696d6572656e646572696e672e636f6d2f666967757265732f7468756d622f525452342e30322e30372e6a7067" alt="" data-canonical-src="http://www.realtimerendering.com/figures/thumb/RTR4.02.07.jpg" style="max-width:100%;"></a></p>
<p>屏幕映射阶段的主要目的，是将之前步骤得到的坐标映射到对应的屏幕坐标系上。</p>
<p><em>unfinished</em></p>
<p>参考：</p>

                        </article>
                    </div>
                </div>
            </div>
        </div>
        
        
     </div>
 </div>
