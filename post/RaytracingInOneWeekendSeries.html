<!DOCTYPE html><html><head>
      <title>RaytracingInOneWeekendSeries</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\hylu\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.5.16\node_modules\@shd101wyy\mume\dependencies\katex\katex.min.css">
      
      
      
      
      
      
      
      
      
      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <p>2020.1.16-2020.1.31&#x7684;&#x5173;&#x4E8E;Raytracing In One Weekend&#x7CFB;&#x5217;&#x7684;notes</p>
<h1 class="mume-header" id="%E8%BE%93%E5%87%BA%E5%9B%BE%E7%89%87">&#x8F93;&#x51FA;&#x56FE;&#x7247;</h1>

<p>&#x539F;&#x6587;&#x4E2D;&#x4F7F;&#x7528;&#x7684;&#x56FE;&#x7247;&#x662F;ppm&#x683C;&#x5F0F;&#xFF0C; &#x662F;&#x4E00;&#x79CD;&#x672A;&#x538B;&#x7F29;&#x7684;&#x683C;&#x5F0F;&#xFF0C;&#x4E00;&#x4E9B;&#x8BBE;&#x5907;&#x4E0D;&#x652F;&#x6301;&#x76F4;&#x63A5;&#x67E5;&#x770B;ppm&#x683C;&#x5F0F;&#x56FE;&#x7247;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4F7F;&#x7528;&#x4E86;&#x4E00;&#x4E2A;&#x5F00;&#x6E90;&#x5E93;svpng&#xFF0C;&#x53EF;&#x4EE5;&#x5C06;rgb&#x989C;&#x8272;&#x4FE1;&#x606F;&#x76F4;&#x63A5;&#x4FDD;&#x5B58;&#x5230;png&#x6587;&#x4EF6;&#x4E2D;</p>
<p>&#x9879;&#x76EE;&#x5730;&#x5740;: <a href="https://github.com/miloyip/svpng">svpng</a></p>
<p>&#x5C06;&#x989C;&#x8272;&#x4FE1;&#x606F;&#x5199;&#x5165;png&#x6587;&#x4EF6;&#x7684;&#x7684;C++&#x4EE3;&#x7801;&#x5982;&#x4E0B;</p>
<pre data-role="codeBlock" data-info class="language-"><code># include &quot;svpng.inc&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-svpnginc&quot;&gt;&lt;/p&gt;


int main() {

    int nx=200,ny=150;// width &amp; height
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen(&quot;test.png&quot;, &quot;wb&quot;);
    for (int j = ny-1; j &gt;= 0; j--)
        for (int i = 0; i &lt; nx; i++) {
            float r = float(i) / float(nx);
            float g = float(j) / float(ny);
            float b = 0.2;
            *p++ = int(255.99*r);    /* R */
            *p++ = int(255.99*g);    /* G */
            *p++ = int(255.99*b);    /* B */
        }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp);
    return 0;
}
</code></pre><p>&#x6E32;&#x67D3;&#x51FA;&#x7684;&#x56FE;&#x7247;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e21457f2fb38b8c3c30944c.png" alt></p>
<p>&#x56FE;&#x7247;&#x4E2D;&#x50CF;&#x7D20;&#x4ECE;&#x5DE6;&#x5230;&#x53F3;&#xFF0C;&#x4ECE;&#x4E0A;&#x5230;&#x4E0B;&#x8F93;&#x51FA;</p>
<p>&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#xFF0C;&#x4ECE;&#x5DE6;&#x5230;&#x53F3;&#xFF0C;&#x7EA2;&#x8272;&#x901A;&#x9053;&#x7684;&#x503C;&#x8D8A;&#x6765;&#x8D8A;&#x5927;&#xFF0C;&#x56FE;&#x50CF;&#x8D8A;&#x6765;&#x8D8A;&#x7EA2;&#xFF0C;&#x4ECE;&#x4E0A;&#x5230;&#x4E0B;&#xFF0C;&#x7EFF;&#x8272;&#x901A;&#x9053;&#x7684;&#x503C;&#x8D8A;&#x6765;&#x8D8A;&#x5927;&#xFF0C;&#x56FE;&#x50CF;&#x8D8A;&#x6765;&#x8D8A;&#x7EFF;</p>
<h1 class="mume-header" id="%E5%90%91%E9%87%8F%E7%B1%BB-vec3h">&#x5411;&#x91CF;&#x7C7B; vec3.h</h1>

<p>&#x6211;&#x4EEC;&#x6784;&#x9020;&#x7684;&#x5411;&#x91CF;&#x7C7B;&#x5982;&#x4E0B;</p>
<pre data-role="codeBlock" data-info class="language-"><code># include &lt;iostream&gt;
&lt;p class=&quot;mume-header &quot; id=&quot;include-iostream&quot;&gt;&lt;/p&gt;

# include &lt;cmath&gt;
&lt;p class=&quot;mume-header &quot; id=&quot;include-cmath&quot;&gt;&lt;/p&gt;

# include &lt;cstdlib&gt;
&lt;p class=&quot;mume-header &quot; id=&quot;include-cstdlib&quot;&gt;&lt;/p&gt;


class vec3 {
public:
    vec3() {}
    vec3(float e0, float e1, float e2) { e[0] = e0; e[1] = e1; e[2] = e2; }
    inline float x() const { return e[0]; }
    inline float y() const { return e[1]; }
    inline float z() const { return e[2]; }
    inline float r() const { return e[0]; }
    inline float g() const { return e[1]; }
    inline float b() const { return e[2]; }

    inline const vec3&amp; operator+() const { return *this; }
    inline vec3 operator-() const { return vec3(-e[0], -e[1], -e[2]); }
    inline float operator[](int i) const { return e[i]; }
    inline float&amp; operator[](int i) { return e[i]; }

    inline vec3&amp; operator+=(const vec3 &amp;v2);
    inline vec3&amp; operator-=(const vec3 &amp;v2);
    inline vec3&amp; operator*=(const vec3 &amp;v2);
    inline vec3&amp; operator/=(const vec3 &amp;v2);
    inline vec3&amp; operator*=(const float t);
    inline vec3&amp; operator/=(const float t);

    inline float length() const { return sqrt(e[0]*e[0] + e[1]*e[1] + e[2]*e[2]); }
    inline float squared_length() const { return e[0]*e[0] + e[1]*e[1] + e[2]*e[2]; }
    inline void make_unit_vector();

    float e[3];
};
</code></pre><p>&#x7C7B;&#x6210;&#x5458;&#x51FD;&#x6570;&#x7684;&#x5B9E;&#x4F8B;&#x5316;</p>
<pre data-role="codeBlock" data-info class="language-"><code>inline std::istream&amp; operator&gt;&gt;(std::istream &amp;is, vec3 &amp;t) {
    is &gt;&gt; t.e[0] &gt;&gt; t.e[1] &gt;&gt; t.e[2];
    return is;
}

inline std::ostream&amp; operator&lt;&lt;(std::ostream &amp;os, const vec3 &amp;t) {
    os &lt;&lt; t.e[0] &lt;&lt; &quot; &quot; &lt;&lt; t.e[1] &lt;&lt; &quot; &quot; &lt;&lt; t.e[2];
    return os;
}

inline void vec3::make_unit_vector() {
    float k = 1.0 / sqrt(e[0]*e[0] + e[1]*e[1] + e[2]*e[2]);
    e[0] *= k; e[1] *= k; e[2] *= k;
}

inline vec3 operator+(const vec3 &amp;v1, const vec3 &amp;v2) {
    return vec3(v1.e[0] + v2.e[0], v1.e[1] + v2.e[1], v1.e[2] + v2.e[2]);
}

inline vec3 operator-(const vec3 &amp;v1, const vec3 &amp;v2) {
    return vec3(v1.e[0] - v2.e[0], v1.e[1] - v2.e[1], v1.e[2] - v2.e[2]);
}

inline vec3 operator*(const vec3 &amp;v1, const vec3 &amp;v2) {
    return vec3(v1.e[0] * v2.e[0], v1.e[1] * v2.e[1], v1.e[2] * v2.e[2]);
}

inline vec3 operator*(float t, const vec3 &amp;v) {
    return vec3(t*v.e[0], t*v.e[1], t*v.e[2]);
}

inline vec3 operator*(const vec3 &amp;v, float t) {
    return vec3(t*v.e[0], t*v.e[1], t*v.e[2]);
}

inline vec3 operator/(const vec3 &amp;v1, const vec3 &amp;v2) {
    return vec3(v1.e[0] / v2.e[0], v1.e[1] / v2.e[1], v1.e[2] / v2.e[2]);
}

inline vec3 operator/(vec3 v, float t) {
    return vec3(v.e[0]/t, v.e[1]/t, v.e[2]/t);
}

inline float dot(const vec3 &amp;v1, const vec3 &amp;v2) {
    return v1.e[0]*v2.e[0]
         + v1.e[1]*v2.e[1]
         + v1.e[2]*v2.e[2];
}

inline vec3 cross(const vec3 &amp;v1, const vec3 &amp;v2) {
    return vec3(v1.e[1] * v2.e[2] - v1.e[2] * v2.e[1],
                v1.e[2] * v2.e[0] - v1.e[0] * v2.e[2],
                v1.e[0] * v2.e[1] - v1.e[1] * v2.e[0]);
}

inline vec3&amp; vec3::operator+=(const vec3 &amp;v) {
    e[0] += v.e[0];
    e[1] += v.e[1];
    e[2] += v.e[2];
    return *this;
}

inline vec3&amp; vec3::operator-=(const vec3&amp; v) {
    e[0] -= v.e[0];
    e[1] -= v.e[1];
    e[2] -= v.e[2];
    return *this;
}

inline vec3&amp; vec3::operator*=(const vec3 &amp;v) {
    e[0] *= v.e[0];
    e[1] *= v.e[1];
    e[2] *= v.e[2];
    return *this;
}

inline vec3&amp; vec3::operator*=(const float t) {
    e[0] *= t;
    e[1] *= t;
    e[2] *= t;
    return *this;
}

inline vec3&amp; vec3::operator/=(const vec3 &amp;v) {
    e[0] /= v.e[0];
    e[1] /= v.e[1];
    e[2] /= v.e[2];
    return *this;
}

inline vec3&amp; vec3::operator/=(const float t) {
    float k = 1.0/t;

    e[0] *= k;
    e[1] *= k;
    e[2] *= k;
    return *this;
}

inline vec3 unit_vector(vec3 v) {
    return v / v.length();
}
</code></pre><p>vec3&#x7C7B;&#x4E2D;&#x7684;&#x6210;&#x5458;&#x53D8;&#x91CF;e[3]&#x53EF;&#x4EE5;&#x8868;&#x793A;&#x4E09;&#x7EF4;&#x7A7A;&#x95F4;&#x4E2D;&#x7684;xyz&#x5750;&#x6807;&#x548C;rgb&#x4E09;&#x4E2A;&#x901A;&#x9053;</p>
<p>&#x7C7B;&#x4E2D;&#x6210;&#x5458;&#x51FD;&#x6570;&#x6709;&#x5411;&#x91CF;&#x957F;&#x5EA6;length&#xFF0C;&#x957F;&#x5EA6;&#x5E73;&#x65B9;squared_length&#xFF0C;&#x5355;&#x4F4D;&#x5316;make_unit_vector</p>
<p>&#x6211;&#x4EEC;&#x66F4;&#x6539;main&#x51FD;&#x6570;&#x4E2D;&#x7684;&#x4EE3;&#x7801;&#x6765;&#x6D4B;&#x8BD5;&#x4E00;&#x4E0B;</p>
<pre data-role="codeBlock" data-info class="language-"><code># include &quot;svpng.inc&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-svpnginc-1&quot;&gt;&lt;/p&gt;

# include &quot;vec3.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-vec3h&quot;&gt;&lt;/p&gt;

int main() {

    int nx=200,ny=150; // width &amp; height
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen(&quot;rgb.png&quot;, &quot;wb&quot;);
    for (int j = ny-1; j &gt;= 0; j--)
        for (int i = 0; i &lt; nx; i++) {
            vec3 col(float(i) / float(nx), float(j) / float(ny), 0.2);
            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */
        }

    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
</code></pre><p>&#x4F1A;&#x5F97;&#x5230;&#x4E0E;&#x4E0A;&#x4E00;&#x7AE0;&#x76F8;&#x540C;&#x7684;&#x56FE;&#x50CF;</p>
<h1 class="mume-header" id="%E5%85%89%E7%BA%BF-%E7%9B%B8%E6%9C%BA-%E8%83%8C%E6%99%AF">&#x5149;&#x7EBF; &#x76F8;&#x673A; &#x80CC;&#x666F;</h1>

<h3 class="mume-header" id="%E5%85%89%E7%BA%BF%E7%B1%BBrayh">&#x5149;&#x7EBF;&#x7C7B;ray.h</h3>

<p>&#x6211;&#x4EEC;&#x4E60;&#x60EF;&#x7528;&#x76F4;&#x7EBF;&#x6765;&#x8868;&#x793A;&#x5149;&#x7EBF;</p>
<p>&#x76F4;&#x7EBF;&#x65B9;&#x7A0B;&#x662F;p(t)=A+t&#x2217;B&#xFF0C;&#x5176;&#x4E2D;&#xFF0C;A&#xFF0C;B&#x90FD;&#x662F;vec3&#x7C7B;&#x578B;&#xFF0C;A&#x662F;&#x5149;&#x7EBF;&#x7684;&#x8D77;&#x70B9;&#xFF0C;B&#x662F;&#x5149;&#x7EBF;&#x7684;&#x65B9;&#x5411;&#xFF0C;t&#x4E3A;&#x4E00;&#x5B9E;&#x6570;&#xFF08;&#x4EE3;&#x7801;&#x4E2D;&#x7528;&#x6D6E;&#x70B9;&#x6570;&#x8868;&#x793A;&#xFF09;&#xFF0C;p(t)&#x5BF9;&#x5E94;t&#x4E0D;&#x540C;&#x53D6;&#x503C;&#x65F6;&#x76F4;&#x7EBF;&#x4E0A;&#x7684;&#x70B9;</p>
<p><img src="https://raytracing.github.io/images/fig-1-04-1.jpg" alt></p>
<p>ray&#x7C7B;&#x7684;&#x4EE3;&#x7801;&#x5982;&#x4E0B;</p>
<pre data-role="codeBlock" data-info class="language-"><code># ifndef RAYH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-rayh&quot;&gt;&lt;/p&gt;

# define RAYH
&lt;p class=&quot;mume-header &quot; id=&quot;define-rayh&quot;&gt;&lt;/p&gt;

# include &quot;vec3.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-vec3h-1&quot;&gt;&lt;/p&gt;


class ray
{
    public:
        ray() {}
        ray(const vec3&amp; a, const vec3&amp; b) { A = a; B = b; }
        vec3 origin() const       { return A; }
        vec3 direction() const    { return B; }
        vec3 point_at_parameter(float t) const { return A + t*B; }

        vec3 A;
        vec3 B;
};

# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif&quot;&gt;&lt;/p&gt;

</code></pre><h3 class="mume-header" id="color%E5%87%BD%E6%95%B0">color&#x51FD;&#x6570;</h3>

<pre data-role="codeBlock" data-info class="language-"><code>vec3 color(const ray&amp; r) {
    vec3 unit_direction = unit_vector(r.direction());
    float t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}
</code></pre><p>color&#x51FD;&#x6570;&#x63A5;&#x6536;&#x4E00;&#x4E2A;ray&#x7C7B;&#x578B;&#x53D8;&#x91CF;r&#xFF0C;&#x5E76;&#x5C06;r&#x7684;&#x65B9;&#x5411;&#x5411;&#x91CF;&#x5355;&#x4F4D;&#x5316;&#xFF0C;t&#x662F;&#x4E00;&#x4E2A;(0,1)&#x4E4B;&#x95F4;&#x7684;&#x6D6E;&#x70B9;&#x6570;&#xFF0C;&#x5149;&#x7EBF;y&#x5206;&#x91CF;&#x8D8A;&#x5C0F;&#xFF0C;t&#x8D8A;&#x5C0F;&#xFF0C;&#x53CD;&#x4E4B;&#xFF0C;t&#x8D8A;&#x5927;<br>
&#x51FD;&#x6570;&#x8FD4;&#x56DE;(1,1,1)&#xFF0C;(0.5,0.7,1.0)&#x989C;&#x8272;&#x7684;&#x63D2;&#x503C;&#x4F5C;&#x4E3A;&#x80CC;&#x666F;&#x989C;&#x8272;</p>
<h3 class="mume-header" id="%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F">&#x5750;&#x6807;&#x7CFB;&#x7EDF;</h3>

<p>&#x4F7F;&#x7528;&#x53F3;&#x624B;&#x5750;&#x6807;&#x7CFB;&#xFF0C;&#x6211;&#x4EEC;&#x5149;&#x7EBF;&#x7684;&#x8D77;&#x70B9;&#x8BBE;&#x4E3A;(0,0,0)&#xFF0C;&#x5C4F;&#x5E55;&#x7684;&#x5750;&#x4E0B;&#x89D2;&#x4E3A;(-2,-1,-1)&#xFF0C;&#x5C4F;&#x5E55;&#x7684;&#x5BBD;&#xFF0C;&#x9AD8;&#x5206;&#x522B;&#x4E3A;4&#xFF0C;2</p>
<pre data-role="codeBlock" data-info class="language-"><code>    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);
</code></pre><p>&#x5982;&#x4E0B;&#x56FE;&#x6240;&#x793A;</p>
<p><img src="https://raytracing.github.io/images/fig-1.03-cam-geom.jpg" alt></p>
<p>&#x4FEE;&#x6539;&#x540E;&#x7684;main&#x51FD;&#x6570;&#x5982;&#x4E0B;</p>
<pre data-role="codeBlock" data-info class="language-"><code># include &quot;svpng.inc&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-svpnginc-2&quot;&gt;&lt;/p&gt;

# include &quot;ray.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-rayh&quot;&gt;&lt;/p&gt;


vec3 color(const ray&amp; r) {
    vec3 unit_direction = unit_vector(r.direction());
    float t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);
}

int main() {

    int nx=600,ny=300;
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen(&quot;test.png&quot;, &quot;wb&quot;);

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);

    for (int j = ny-1; j &gt;= 0; j--)
        for (int i = 0; i &lt; nx; i++) {
            float u = float(i) / float(nx);
            float v = float(j) / float(ny);
            ray r(origin, lower_left_corner + u*horizontal + v*vertical);
            vec3 col = color(r);

            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */
        }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
</code></pre><p>&#x6E32;&#x67D3;&#x51FA;&#x7684;&#x56FE;&#x50CF;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e2174ab2fb38b8c3c384130.png" alt></p>
<p>&#x5728;&#x7AD6;&#x76F4;&#x65B9;&#x5411;&#xFF0C;&#x56FE;&#x50CF;&#x7684;&#x989C;&#x8272;&#x7531;&#x767D;&#x8272;(0,0,0)&#x6E10;&#x53D8;&#x5230;&#x84DD;&#x8272;(0.5,0.8,1.0)&#xFF0C;&#x5728;&#x6C34;&#x5E73;&#x65B9;&#x5411;&#xFF0C;&#x7531;&#x4E8E;&#x5149;&#x7EBF;&#x5411;&#x91CF;&#x7684;y&#x5206;&#x91CF;&#x76F8;&#x540C;&#xFF0C;&#x989C;&#x8272;&#x4E0D;&#x53D8;&#x5316;</p>
<h1 class="mume-header" id="%E7%90%83%E4%BD%93-%E8%A1%A8%E9%9D%A2%E6%B3%95%E7%BA%BF-%E5%A4%9A%E7%89%A9%E4%BD%93">&#x7403;&#x4F53; &#x8868;&#x9762;&#x6CD5;&#x7EBF; &#x591A;&#x7269;&#x4F53;</h1>

<h3 class="mume-header" id="hittable%E7%B1%BB">hittable&#x7C7B;</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef HITTABLEH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-hittableh&quot;&gt;&lt;/p&gt;

# define HITTABLEH
&lt;p class=&quot;mume-header &quot; id=&quot;define-hittableh&quot;&gt;&lt;/p&gt;


# include &quot;ray.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-rayh-1&quot;&gt;&lt;/p&gt;


struct hit_record {
    float t;
    vec3 p;
    vec3 normal;
};

class hittable  {
    public:
        virtual bool hit(
            const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const = 0;
};

# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-1&quot;&gt;&lt;/p&gt;

</code></pre><p>hittable&#x662F;&#x4E00;&#x4E2A;&#x62BD;&#x8C61;&#x7C7B;&#xFF0C;&#x5176;&#x4E2D;&#x5B9A;&#x4E49;&#x4E86;&#x6570;&#x636E;&#x7C7B;&#x578B;hit_record&#xFF0C;&#x5305;&#x542B;&#x5149;&#x7EBF;&#x4E0E;&#x8868;&#x9762;&#x7684;&#x4EA4;&#x70B9;p&#xFF0C;&#x4EA4;&#x70B9;&#x7684;&#x6CD5;&#x7EBF;&#x65B9;&#x5411;normal&#xFF0C;t&#x7528;&#x4E8E;&#x8BB0;&#x5F55;&#x79BB;&#x89C2;&#x5BDF;&#x8005;&#x6700;&#x8FD1;&#x7684;&#x70B9;</p>
<p>hit&#x51FD;&#x6570;&#x63A5;&#x6536;ray&#x7C7B;&#x578B;&#x53D8;&#x91CF;r&#xFF0C;t_min&#xFF0C;t_max&#xFF0C;&#x5E76;&#x5C06;hit&#x4FE1;&#x606F;&#x4FDD;&#x5B58;&#x5728;rec&#x4E2D;</p>
<h3 class="mume-header" id="%E7%90%83%E4%BD%93%E7%B1%BB-sphereh">&#x7403;&#x4F53;&#x7C7B; sphere.h</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef SPHEREH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-sphereh&quot;&gt;&lt;/p&gt;

# define SPHEREH
&lt;p class=&quot;mume-header &quot; id=&quot;define-sphereh&quot;&gt;&lt;/p&gt;


# include &quot;hittable.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-hittableh&quot;&gt;&lt;/p&gt;


class sphere: public hittable  {
    public:
        sphere() {}
        sphere(vec3 cen, float r) : center(cen), radius(r)  {};
        virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const;
        vec3 center;
        float radius;
};

bool sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    float a = dot(r.direction(), r.direction());
    float b = dot(oc, r.direction());
    float c = dot(oc, oc) - radius*radius;
    float discriminant = b*b - a*c;

    if (discriminant &gt; 0) {
        float temp = (-b - sqrt(discriminant))/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            return true;
        }
        temp = (-b + sqrt(discriminant)) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            return true;
        }
    }
    //no roots
    return false;
}


# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-2&quot;&gt;&lt;/p&gt;

</code></pre><p>sphere&#x7C7B;&#x7EE7;&#x627F;&#x81EA;hittable&#x7C7B;&#x7684;&#x521D;&#x59CB;&#x5316;&#x9700;&#x8981;&#x7403;&#x5FC3;cent&#x548C;&#x534A;&#x5F84;r&#x4E24;&#x4E2A;&#x53D8;&#x91CF;</p>
<p>hit&#x51FD;&#x6570;&#x7528;&#x4E8E;&#x8BA1;&#x7B97;&#x5149;&#x7EBF;&#x662F;&#x5426;&#x4E0E;&#x7403;&#x4F53;&#x76F8;&#x4EA4;&#xFF0C;&#x6570;&#x5B66;&#x63A8;&#x5BFC;&#x5982;&#x4E0B;:</p>
<p>&#x6211;&#x4EEC;&#x901A;&#x5E38;&#x7528; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mtext>&#x2212;</mtext><mi>C</mi><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mtext>&#x2212;</mtext><mi>C</mi><mi>y</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>z</mi><mtext>&#x2212;</mtext><mi>C</mi><mi>z</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x&#x2212;Cx)^2+(y&#x2212;Cy)^2+(z&#x2212;Cz)^2=R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> &#x8868;&#x793A;&#x7403;&#x5FC3;&#x4E3A;(Cx,Cy,Cz)&#x7684;&#x7403;&#x4F53;</p>
<p>&#x6211;&#x4EEC;&#x8BB0; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mo stretchy="false">(</mo><mi>C</mi><mi>x</mi><mo separator="true">,</mo><mi>C</mi><mi>y</mi><mo separator="true">,</mo><mi>C</mi><mi>z</mi><mo stretchy="false">)</mo><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C=(Cx,Cy,Cz) P=(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></p>
<p>&#x90A3;&#x4E48; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>P</mi><mo>&#x2212;</mo><mi>C</mi><mo separator="true">,</mo><mi>P</mi><mo>&#x2212;</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mtext>&#x2212;</mtext><mi>C</mi><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mtext>&#x2212;</mtext><mi>C</mi><mi>y</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>z</mi><mtext>&#x2212;</mtext><mi>C</mi><mi>z</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">dot(P-C,P-C)=(x&#x2212;Cx)^2+(y&#x2212;Cy)^2+(z&#x2212;Cz)^2=R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">&#x2212;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">&#x2212;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p>&#x70B9;P&#x7684;&#x5750;&#x6807;&#x53EF;&#x4EE5;&#x7528;ray&#x7C7B;&#x4E2D;&#x7684;point_at_parameter&#x51FD;&#x6570;&#x5F97;&#x5230;&#xFF0C;&#x5373; <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mo>+</mo><mi>t</mi><mtext>&#x2217;</mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">p(t)=A+t&#x2217;B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">t</span><span class="mord">&#x2217;</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></p>
<p>&#x6539;&#x5199;&#x65B9;&#x7A0B;&#x5982;&#x4E0B;</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mtext>&#x2212;</mtext><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mtext>&#x2212;</mtext><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>A</mi><mo>+</mo><mi>t</mi><mtext>&#x2217;</mtext><mi>B</mi><mtext>&#x2212;</mtext><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>A</mi><mo>+</mo><mi>t</mi><mtext>&#x2217;</mtext><mi>B</mi><mtext>&#x2212;</mtext><mi>C</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">dot((p(t)&#x2212;C),(p(t)&#x2212;C))=dot((A+t&#x2217;B&#x2212;C),(A+t&#x2217;B&#x2212;C))=R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord">&#x2217;</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord">&#x2217;</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mn>2</mn></msup><mo>&#x22C5;</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mi>t</mi><mo>&#x22C5;</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mtext>&#x2212;</mtext><mi>C</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>o</mi><mi>t</mi><mo stretchy="false">(</mo><mi>A</mi><mtext>&#x2212;</mtext><mi>C</mi><mo separator="true">,</mo><mi>A</mi><mtext>&#x2212;</mtext><mi>C</mi><mo stretchy="false">)</mo><mtext>&#x2212;</mtext><msup><mi>R</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t^2&#x22C5;dot(B,B)+2t&#x22C5;dot(B,A&#x2212;C)+dot(A&#x2212;C,A&#x2212;C)&#x2212;R^2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">&#x22C5;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">&#x22C5;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mord">&#x2212;</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord">&#x2212;</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>&#x6211;&#x4EEC;&#x8981;&#x505A;&#x7684;&#x5C31;&#x662F;&#x5BF9;&#x4E0D;&#x540C;&#x7684;t&#x6C42;&#x51FA;&#x6B64;&#x65B9;&#x7A0B;&#x7684;&#x89E3;&#xFF08;&#x4EE3;&#x7801;&#x4E2D;&#x5728;&#x65B9;&#x7A0B;&#x7684;&#x7CFB;&#x6570;&#x4E0A;&#x7A0D;&#x6709;&#x53D8;&#x5316;&#xFF0C;&#x4F46;&#x4E0D;&#x5F71;&#x54CD;&#x7ED3;&#x679C;&#x7684;&#x6B63;&#x8D1F;&#xFF09;</p>
<p><img src="https://raytracing.github.io/images/fig-1.04-ray-sphere.jpg" alt></p>
<p>&#x5224;&#x522B;&#x5F0F;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>b</mi><mn>2</mn></msup><mo>&#x2212;</mo><mn>4</mn><mi>a</mi><mi>c</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(b^2-4ac)&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">&#x2212;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>&#xFF0C;&#x65B9;&#x7A0B;&#x65E0;&#x5B9E;&#x6570;&#x89E3;&#x65F6;&#xFF1A;&#x5149;&#x7EBF;&#x4E0E;&#x7403;&#x4F53;&#x65E0;&#x4EA4;&#x70B9;&#xFF0C;&#x8F93;&#x51FA;&#x80CC;&#x666F;&#x8272;</p>
<p>&#x5224;&#x522B;&#x5F0F;&gt;0&#x65F6;&#xFF0C;&#x65B9;&#x7A0B;&#x6709;&#x4E24;&#x4E2A;&#x89E3;r1&#xFF0C;r2&#xFF0C;&#x6211;&#x4EEC;&#x9996;&#x5148;&#x8003;&#x5BDF;&#x8DDD;&#x79BB;&#x89C2;&#x5BDF;&#x70B9;&#x89D2;&#x8F83;&#x8FD1;&#x7684;&#x4EA4;&#x70B9;&#xFF0C;&#x5373;&#x65B9;&#x7A0B;&#x89E3;&#x4E2D;&#x8F83;&#x5C0F;&#x7684;&#x4E00;&#x4E2A;&#xFF0C;&#x56E0;&#x4E3A;&#x5149;&#x7EBF;&#x4E0D;&#x4F1A;&#x7A7F;&#x8FC7;&#x7269;&#x4F53;&#xFF0C;&#x53EA;&#x4F1A;&#x7167;&#x5C04;&#x5230;&#x7403;&#x4F53;&#x4E0A;&#x8F83;&#x8FD1;&#x7684;&#x70B9;&#xFF08;&#x6211;&#x4EEC;&#x5047;&#x8BBE;&#x7269;&#x4F53;&#x662F;&#x5B8C;&#x5168;&#x4E0D;&#x900F;&#x660E;&#x7684;&#xFF09;&#xFF0C;&#x8BB0;&#x5F55;&#x4EA4;&#x70B9;&#x7684;t&#x503C;&#xFF0C;&#x5750;&#x6807;p&#xFF0C;&#x548C;&#x6CD5;&#x7EBF;&#x65B9;&#x5411;n</p>
<hr>
<h3 class="mume-header" id="hittablelist%E7%B1%BB-%E5%A4%9A%E7%89%A9%E4%BD%93">hittablelist&#x7C7B; &#x591A;&#x7269;&#x4F53;</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef HITTABLELISTH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-hittablelisth&quot;&gt;&lt;/p&gt;

# define HITTABLELISTH
&lt;p class=&quot;mume-header &quot; id=&quot;define-hittablelisth&quot;&gt;&lt;/p&gt;


# include &quot;hittable.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-hittableh-1&quot;&gt;&lt;/p&gt;


class hittable_list: public hittable {
    public:
        hittable_list() {}
        hittable_list(hittable **l, int n) {list = l; list_size = n; }
        virtual bool hit(
            const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const;
        hittable **list;
        int list_size;
};

bool hittable_list::hit(const ray&amp; r, float t_min, float t_max,
                        hit_record&amp; rec) const {

    hit_record temp_rec;
    bool hit_anything = false;
    double closest_so_far = t_max;
    for (int i = 0; i &lt; list_size; i++) {
        if (list[i]-&gt;hit(r, t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }
    return hit_anything;
}

# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-3&quot;&gt;&lt;/p&gt;

</code></pre><p>hittablelist&#x7C7B;&#x4F1A;&#x8BA1;&#x7B97;&#x51FA;&#x5149;&#x7EBF;&#x4E0E;&#x591A;&#x4E2A;&#x7403;&#x4F53;&#x6700;&#x8FD1;&#x7684;&#x4EA4;&#x70B9;</p>
<p>&#x4FEE;&#x6539;&#x540E;&#x7684;main&#x51FD;&#x6570;</p>
<pre data-role="codeBlock" data-info class="language-"><code># include &quot;svpng.inc&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-svpnginc-3&quot;&gt;&lt;/p&gt;

# include &quot;sphere.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-sphereh&quot;&gt;&lt;/p&gt;

# include &quot;hittablelist.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-hittablelisth&quot;&gt;&lt;/p&gt;

# include&lt;cfloat&gt;
&lt;p class=&quot;mume-header &quot; id=&quot;includecfloat&quot;&gt;&lt;/p&gt;


vec3 color(const ray&amp; r, hittable *world) {
    hit_record rec;
    if (world-&gt;hit(r, 0.0, FLT_MAX, rec)) {
        return 0.5*vec3(rec.normal.x()+1, rec.normal.y()+1, rec.normal.z()+1);
    }
    else{
    vec3 unit_direction = unit_vector(r.direction());
    float t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);   
    }
}

int main() {

    int nx=600,ny=300;
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen(&quot;test.png&quot;, &quot;wb&quot;);

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);

    hittable *list[2];
    list[0] = new sphere(vec3(0,0,-1), 0.5);
    list[1] = new sphere(vec3(0,-100.5,-1), 100);
    hittable *world = new hittable_list(list,2);
    
    for (int j = ny-1; j &gt;= 0; j--)
        for (int i = 0; i &lt; nx; i++) {

            float u = float(i) / float(nx);
            float v = float(j) / float(ny);
            ray r(origin, lower_left_corner + u*horizontal + v*vertical);
            vec3 pap = r.point_at_parameter(2.0);
            vec3 col = color(r, world);
            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */
        }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
</code></pre><p>&#x5728;color&#x51FD;&#x6570;&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x5149;&#x7EBF;&#x7167;&#x5C04;&#x5230;&#x4E86;&#x7403;&#x4F53;&#x4E0A;&#xFF0C;&#x4F1A;&#x6839;&#x636E;&#x4EA4;&#x70B9;&#x7684;&#x6CD5;&#x7EBF;&#x65B9;&#x5411;&#xFF0C;&#x6539;&#x53D8;&#x989C;&#x8272;&#x7684;&#x503C;</p>
<hr>
<p>&#x4EA7;&#x751F;&#x7684;&#x56FE;&#x7247;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e2180132fb38b8c3c398a66.png" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary V - Antialiasing<br>
date: 2020-01-19</p>
<hr>
<h1 class="mume-header" id="%E6%8A%97%E9%94%AF%E9%BD%BF">&#x6297;&#x952F;&#x9F7F;</h1>

<h3 class="mume-header" id="random%E7%B1%BB">random&#x7C7B;</h3>

<p>&#x5148;&#x5F15;&#x7528;&#x6211;&#x4EEC;&#x4E0A;&#x4E00;&#x7AE0;&#x6240;&#x751F;&#x6210;&#x7684;&#x56FE;&#x50CF;</p>
<p><img src="https://pic.downk.cc/item/5e2180132fb38b8c3c398a66.png" alt></p>
<p>&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#xFF0C;&#x5728;&#x7403;&#x4F53;&#x7684;&#x8FB9;&#x7F18;&#x4F1A;&#x6709;&#x660E;&#x663E;&#x7684;&#x952F;&#x9F7F;&#x611F;&#xFF0C;&#x51CF;&#x5C11;&#x952F;&#x9F7F;&#x611F;&#x7684;&#x65B9;&#x6CD5;&#x662F;&#xFF0C;&#x5728;&#x8BA1;&#x7B97;&#x67D0;&#x4E00;&#x4E2A;&#x50CF;&#x7D20;&#x7684;&#x989C;&#x8272;&#x65F6;&#xFF0C;&#x8BA1;&#x7B97;&#x5B83;&#x90BB;&#x8FD1;&#x7684;&#x533A;&#x57DF;&#x5185;&#x591A;&#x4E2A;&#x91C7;&#x6837;&#x70B9;&#x7684;&#x989C;&#x8272;&#xFF0C;&#x5E76;&#x6C42;&#x5E73;&#x5747;&#x503C;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x5F15;&#x5165;&#x4E00;&#x4E2A;random&#x7C7B;</p>
<pre data-role="codeBlock" data-info class="language-"><code># ifndef RANDOMH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-randomh&quot;&gt;&lt;/p&gt;

# define RANDOMH
&lt;p class=&quot;mume-header &quot; id=&quot;define-randomh&quot;&gt;&lt;/p&gt;


# include &lt;cstdlib&gt;
&lt;p class=&quot;mume-header &quot; id=&quot;include-cstdlib-1&quot;&gt;&lt;/p&gt;


inline double random_double() {
    return rand() / (RAND_MAX + 1.0);
}
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-4&quot;&gt;&lt;/p&gt;

</code></pre><p>random_double&#x51FD;&#x6570;&#x751F;&#x6210;&#x4E00;&#x4E2A;(0,1)&#x4E4B;&#x95F4;&#x7684;&#x6D6E;&#x70B9;&#x6570;</p>
<hr>
<h3 class="mume-header" id="camera%E7%B1%BB">camera&#x7C7B;</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef CAMERAH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-camerah&quot;&gt;&lt;/p&gt;

# define CAMERAH
&lt;p class=&quot;mume-header &quot; id=&quot;define-camerah&quot;&gt;&lt;/p&gt;


# include &quot;ray.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-rayh-2&quot;&gt;&lt;/p&gt;


class camera {
    public:
        camera() {
            lower_left_corner = vec3(-2.0, -1.0, -1.0);
            horizontal = vec3(4.0, 0.0, 0.0);
            vertical = vec3(0.0, 2.0, 0.0);
            origin = vec3(0.0, 0.0, 0.0);
        }
        ray get_ray(float u, float v) {
            return ray(origin,
                       lower_left_corner + u*horizontal + v*vertical - origin);
        }

        vec3 origin;
        vec3 lower_left_corner;
        vec3 horizontal;
        vec3 vertical;
};
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-5&quot;&gt;&lt;/p&gt;

</code></pre><p>amera&#x7C7B;&#x7528;&#x4E8E;&#x53D1;&#x5C04;&#x4E0D;&#x540C;&#x7684;&#x5149;&#x7EBF;&#xFF0C;&#x7528;&#x4E8E;&#x91C7;&#x6837;</p>
<hr>
<p>&#x4FEE;&#x6539;&#x540E;&#x7684;main&#x51FD;&#x6570;</p>
<pre data-role="codeBlock" data-info class="language-"><code># include &quot;svpng.inc&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-svpnginc-4&quot;&gt;&lt;/p&gt;

# include &quot;sphere.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-sphereh-1&quot;&gt;&lt;/p&gt;

# include &quot;hittablelist.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-hittablelisth-1&quot;&gt;&lt;/p&gt;

# include &quot;camera.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-camerah&quot;&gt;&lt;/p&gt;

# include &quot;random.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-randomh&quot;&gt;&lt;/p&gt;

# include&lt;cfloat&gt;
&lt;p class=&quot;mume-header &quot; id=&quot;includecfloat-1&quot;&gt;&lt;/p&gt;


vec3 color(const ray&amp; r, hittable *world) {
    hit_record rec;
    if (world-&gt;hit(r, 0.0, FLT_MAX, rec)) {
        return 0.5*vec3(rec.normal.x()+1, rec.normal.y()+1, rec.normal.z()+1);
    }
    else{
    vec3 unit_direction = unit_vector(r.direction());
    float t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);   
    }
 
}

int main() {

    int nx=600,ny=300,ns=100;
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen(&quot;test.png&quot;, &quot;wb&quot;);

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);
    camera cam;
    hittable *list[2];
    list[0] = new sphere(vec3(0,0,-1), 0.5);
    list[1] = new sphere(vec3(0,-100.5,-1), 100);
    hittable *world = new hittable_list(list,2);

    for (int j = ny-1; j &gt;= 0; j--){
        for (int i = 0; i &lt; nx; i++) {
            vec3 col(0,0,0);
            for(int s = 0; s &lt; ns ; s++){
                float u = float(i + random_double()) / float(nx);
                float v = float(j + random_double()) / float(ny);
                ray r = cam.get_ray(u,v);               
                col += color(r, world);           
            }
            col /= float(ns);
            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */   
        }
    }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
</code></pre><p>&#x6211;&#x4EEC;&#x4EE5;&#x91C7;&#x6837;100&#x6B21;&#x4E3A;&#x4F8B;&#xFF08;ns=100&#xFF09;</p>
<hr>
<p>&#x6E32;&#x67D3;&#x51FA;&#x7684;&#x56FE;&#x7247;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e226b362fb38b8c3c4eef5c.png" alt></p>
<p>&#x7403;&#x4F53;&#x8FB9;&#x7F18;&#x5904;&#x7684;&#x50CF;&#x7D20;&#x952F;&#x9F7F;&#x611F;&#x660E;&#x663E;&#x964D;&#x4F4E;</p>
<h1 class="mume-header" id="%E6%9D%90%E8%B4%A8">&#x6750;&#x8D28;</h1>

<hr>
<h3 class="mume-header" id="%E6%9D%90%E8%B4%A8%E7%B1%BB">&#x6750;&#x8D28;&#x7C7B;</h3>

<pre data-role="codeBlock" data-info class="language-"><code>class material{
public:
    virtual bool scatter(
        const ray&amp; r_in,
        const hit_record&amp; rec,
        vec3&amp; attenuation,
        ray&amp; scattered) const = 0;
};
</code></pre><p>scatter&#x51FD;&#x6570;&#x63A5;&#x53D7;&#x4E00;&#x6761;&#x5149;&#x7EBF;r_in&#xFF0C;&#x78B0;&#x649E;&#x8BB0;&#x5F55;rec&#xFF0C;&#x8870;&#x51CF;attenuation&#xFF0C;&#x548C;&#x6563;&#x5C04;&#x540E;&#x7684;&#x5149;&#x7EBF;scattered</p>
<p>&#x540C;&#x65F6;&#x8981;&#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#x4E2D;&#x7A0D;&#x505A;&#x4FEE;&#x6539;</p>
<p>sphere.h</p>
<pre data-role="codeBlock" data-info class="language-"><code># ifndef SPHEREH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-sphereh-1&quot;&gt;&lt;/p&gt;

# define SPHEREH
&lt;p class=&quot;mume-header &quot; id=&quot;define-sphereh-1&quot;&gt;&lt;/p&gt;


# include &quot;hittable.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-hittableh-2&quot;&gt;&lt;/p&gt;


class sphere: public hittable  {
    public:
        sphere() {}
        sphere(vec3 cen, float r, material *m) : center(cen), radius(r), mat_ptr(m)  {};
        virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const;
        vec3 center;
        float radius;
        material *mat_ptr; /* NEW */
};

bool sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    float a = dot(r.direction(), r.direction());
    float b = dot(oc, r.direction());
    float c = dot(oc, oc) - radius*radius;
    float discriminant = b*b - a*c;
    if (discriminant &gt; 0) {
        float temp = (-b - sqrt(discriminant))/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; /* NEW */
            return true;
        }
        temp = (-b + sqrt(discriminant)) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; /* NEW */
            return true;
        }
    }
    return false;
}
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-6&quot;&gt;&lt;/p&gt;

</code></pre><p>hittable.h</p>
<pre data-role="codeBlock" data-info class="language-"><code># ifndef HITTABLEH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-hittableh-1&quot;&gt;&lt;/p&gt;

# define HITTABLEH
&lt;p class=&quot;mume-header &quot; id=&quot;define-hittableh-1&quot;&gt;&lt;/p&gt;

# include &quot;ray.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-rayh-3&quot;&gt;&lt;/p&gt;


class material;

struct hit_record {
    float t;
    vec3 p;
    vec3 normal;
    material *mat_ptr;
};

class hittable  {
    public:
        virtual bool hit(
            const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const = 0;
};

# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-7&quot;&gt;&lt;/p&gt;

</code></pre><p>&#x6DFB;&#x52A0;&#x7C7B;&#x6210;&#x5458;mat_ptr&#x7528;&#x4E8E;&#x5728;&#x7403;&#x4F53;&#x521D;&#x59CB;&#x5316;&#x65F6;&#x6307;&#x5B9A;&#x6750;&#x8D28;</p>
<hr>
<h3 class="mume-header" id="%E6%BC%AB%E5%8F%8D%E5%B0%84-diffuse">&#x6F2B;&#x53CD;&#x5C04; diffuse</h3>

<p>&#x6211;&#x4EEC;&#x7528;lambert&#x5149;&#x7167;&#x6A21;&#x578B;&#x6A21;&#x62DF;&#x6F2B;&#x53CD;&#x5C04;&#xFF0C;lambert&#x6A21;&#x578B;&#x7528;&#x4E8E;&#x7EAF;&#x7CB9;&#x7684;&#x6F2B;&#x53CD;&#x5C04;&#x8868;&#x9762;&#x7684;&#x7269;&#x4F53;&#xFF0C;&#x5149;&#x6E90;&#x7167;&#x5C04;&#x5230;&#x7269;&#x4F53;&#x8868;&#x9762;&#x540E;&#xFF0C;&#x5411;&#x56DB;&#x9762;&#x516B;&#x65B9;&#x53CD;&#x5C04;&#xFF0C;&#x4EA7;&#x751F;&#x6F2B;&#x53CD;&#x5C04;&#x6548;&#x679C;&#x3002;</p>
<p><img src="https://raytracing.github.io/images/fig-1-08-1.jpg" alt></p>
<p>&#x5982;&#x56FE;&#x6240;&#x793A;&#xFF0C;&#x5149;&#x7EBF;&#x5728;&#x7167;&#x5C04;&#x5230;&#x5E73;&#x9762;&#x4E0A;&#x65F6;&#x53CD;&#x5C04;&#x7684;&#x65B9;&#x5411;&#x662F;&#x968F;&#x673A;&#x7684;</p>
<p>random.h</p>
<pre data-role="codeBlock" data-info class="language-"><code>vec3 random_in_unit_sphere() {
    vec3 p;
    do {
        p = 2.0*vec3(random_double(), random_double(), random_double()) - vec3(1,1,1);
    } while (p.squared_length() &gt;= 1.0);
    return p;
}
</code></pre><p>random_in_unit_sphere&#x751F;&#x6210;&#x4E00;&#x4E2A;&#x957F;&#x5EA6;&#x4E3A;1&#x7684;&#x968F;&#x673A;&#x5411;&#x91CF;</p>
<p><img src="https://raytracing.github.io/images/fig-1-08-2.jpg" alt></p>
<p>&#x8868;&#x9762;&#x6CD5;&#x7EBF;&#x4E3A; <strong>n</strong>&#xFF0C;&#x5149;&#x7EBF;&#x4E0E;&#x8868;&#x9762;&#x4EA4;&#x70B9; <strong>p</strong>&#xFF0C;&#x968F;&#x673A;&#x5411;&#x91CF; <strong>random</strong>&#xFF0C;<strong>p+n+random</strong>&#x5C31;&#x662F;&#x6F2B;&#x53CD;&#x5C04;&#x7684;&#x65B9;&#x5411;</p>
<p>&#x6DFB;&#x52A0;material&#x7684;&#x5B50;&#x7C7B;lambertian</p>
<pre data-role="codeBlock" data-info class="language-"><code>class lambertian : public material {
    public:
        lambertian(const vec3&amp; a) : albedo(a) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const {
            vec3 target = rec.p + rec.normal + random_in_unit_sphere();
            scattered = ray(rec.p, target-rec.p);
            attenuation = albedo;
            return true;
        }
        vec3 albedo;
};
</code></pre><p>&#x8FD4;&#x56DE;&#x503C;&#x4E3A;true&#xFF0C;scattered&#x4E3A;&#x53CD;&#x5C04;&#x5149;&#x7EBF;</p>
<hr>
<h3 class="mume-header" id="%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84-specular">&#x9AD8;&#x5149;&#x53CD;&#x5C04; specular</h3>

<p>&#x8BA1;&#x7B97;&#x53CD;&#x5C04;&#x65B9;&#x5411;&#xFF0C;&#x6570;&#x5B66;&#x63A8;&#x5BFC;&#x5982;&#x4E0B;</p>
<p><img src="https://raytracing.github.io/images/fig-1-09-1.jpg" alt></p>
<p>&#x6211;&#x4EEC;&#x5DF2;&#x77E5;&#x5165;&#x5C04;&#x65B9;&#x5411; <strong>v</strong>&#xFF0C;&#x8868;&#x9762;&#x6CD5;&#x7EBF;&#x65B9;&#x5411; <strong>n</strong>&#x4E14;&#x957F;&#x5EA6;&#x4E3A;1&#xFF0C;v&#x5728;n&#x65B9;&#x5411;&#x4E0A;&#x7684;&#x6295;&#x5F71;&#x4E3A; <strong>dot(n,v)</strong>&#xFF0C;&#x53CD;&#x5C04;&#x65B9;&#x5411;&#x5373;&#x4E3A; <strong>v-2&#xB7;n&#xB7;dot(v,n)</strong></p>
<p>&#x8BA1;&#x7B97;&#x53CD;&#x5C04;&#x65B9;&#x5411;&#x7684;&#x51FD;&#x6570;reflect</p>
<pre data-role="codeBlock" data-info class="language-"><code>vec3 reflect(const vec3&amp; v, const vec3&amp; n) {
    return v - 2*dot(v,n)*n;
}
</code></pre><p>&#x6DFB;&#x52A0;material&#x7684;&#x81EA;&#x7C7B;metal</p>
<pre data-role="codeBlock" data-info class="language-"><code>class metal : public material {
    public:
        metal(const vec3&amp; a) : albedo(a) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec,
                             vec3&amp; attenuation, ray&amp; scattered) const {
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            scattered = ray(rec.p, reflected);
            attenuation = albedo;
            return (dot(scattered.direction(), rec.normal) &gt; 0);
        }
        vec3 albedo;
};
</code></pre><hr>
<p>&#x4FEE;&#x6539;&#x540E;&#x7684;main&#x51FD;&#x6570;</p>
<pre data-role="codeBlock" data-info class="language-"><code># include &quot;svpng.inc&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-svpnginc-5&quot;&gt;&lt;/p&gt;

# include &quot;sphere.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-sphereh-2&quot;&gt;&lt;/p&gt;

# include &quot;hittablelist.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-hittablelisth-2&quot;&gt;&lt;/p&gt;

# include &quot;camera.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-camerah-1&quot;&gt;&lt;/p&gt;

# include &quot;random.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-randomh-1&quot;&gt;&lt;/p&gt;

# include &quot;material.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-materialh&quot;&gt;&lt;/p&gt;

# include&lt;cfloat&gt;
&lt;p class=&quot;mume-header &quot; id=&quot;includecfloat-2&quot;&gt;&lt;/p&gt;


vec3 color(const ray&amp; r, hittable *world, int depth) {
    hit_record rec;
    if (world-&gt;hit(r, 0.001, FLT_MAX, rec)) {
        ray scattered;
        vec3 attenuation;
        if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered)) {
            return attenuation*color(scattered, world, depth+1);
        }
        else {
            return vec3(0,0,0);
        }
    }
    else{
    vec3 unit_direction = unit_vector(r.direction());
    float t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);   
    }
}

int main() {

    int nx=600,ny=300,ns=100;
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen(&quot;test.png&quot;, &quot;wb&quot;);

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);
    camera cam;
    hittable *list[4];
    list[0] = new sphere(vec3(0,0,-1), 0.5, new lambertian(vec3(0.8, 0.3, 0.3)));
    list[1] = new sphere(vec3(0,-100.5,-1), 100, new lambertian(vec3(0.8, 0.8, 0.0)));
    list[2] = new sphere(vec3(1,0,-1), 0.5, new lambertian(vec3(0.2,0.2,0.8)));
    list[3] = new sphere(vec3(-1,0,-1), 0.5, new metal(vec3(0.8, 0.8, 0.8)));
    hittable *world = new hittable_list(list,4);

    for (int j = ny-1; j &gt;= 0; j--){
        for (int i = 0; i &lt; nx; i++) {
            vec3 col(0,0,0);
            for(int s = 0; s &lt; ns ; s++){
                float u = float(i + random_double()) / float(nx);
                float v = float(j + random_double()) / float(ny);
                ray r = cam.get_ray(u,v);               
                col += color(r, world, 0);           
            }
            col /= float(ns);
            col = vec3( sqrt(col[0]), sqrt(col[1]), sqrt(col[2]) );
            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */   
        }
    }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
</code></pre><p>&#x5728;color&#x51FD;&#x6570;&#x4E2D;&#xFF0C;depth&#x7684;&#x503C;&#x4E3A;&#x5149;&#x7EBF;&#x53CD;&#x5C04;&#x7684;&#x6B21;&#x6570;</p>
<p>depth=0</p>
<p><img src="https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4570.png" alt></p>
<p>depth=1</p>
<p><img src="https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4572.png" alt></p>
<p>depth=2</p>
<p><img src="https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4574.png" alt></p>
<p>depth=1000</p>
<p><img src="https://pic.downk.cc/item/5e22de9e2fb38b8c3c59f22f.png" alt></p>
<p>&#x53CD;&#x5C04;&#x6B21;&#x6570;&#x8D8A;&#x591A;&#xFF0C;&#x56FE;&#x50CF;&#x8D8A;&#x7406;&#x60F3;</p>
<p>&#x5728;&#x8FED;&#x4EE3;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5047;&#x8BBE;&#x5149;&#x7EBF;&#x65E0;&#x8870;&#x51CF;&#xFF0C;attenuation&#x503C;&#x4E0D;&#x53D8;&#xFF0C;&#x4E3A;&#x7269;&#x4F53;&#x8868;&#x9762;&#x7684;&#x989C;&#x8272;&#xFF0C;&#x56E0;&#x4E3A;attenuation&lt;0&#xFF0C;&#x53CD;&#x5C04;&#x6B21;&#x6570;&#x8D8A;&#x591A;&#xFF0C;&#x5149;&#x7EBF;&#x989C;&#x8272;&#x7684;rgb&#x503C;&#x8D8A;&#x6765;&#x8D8A;&#x5C0F;&#xFF0C;&#x8D8B;&#x8FD1;&#x4E0E;0&#xFF0C;&#x8FD9;&#x4E5F;&#x662F;&#x4E3A;&#x4EC0;&#x4E48;&#x5728;&#x7403;&#x4F53;&#x7684;&#x4EA4;&#x754C;&#x5904;&#x4EA7;&#x751F;&#x9634;&#x5F71;&#x7684;&#x539F;&#x56E0;</p>
<hr>
<h3 class="mume-header" id="gamma-correction">gamma correction</h3>

<p><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/#gamma">&#x4E00;&#x7BC7;&#x5BF9;gamma&#x77EB;&#x6B63;&#x7684;&#x4ECB;&#x7ECD;</a></p>
<p>&#x4EBA;&#x773C;&#x5BF9;&#x7070;&#x9636;&#x7684;&#x611F;&#x77E5;&#x4E0D;&#x662F;&#x7EBF;&#x6027;&#x7684;&#xFF0C;&#x800C;&#x662F;&#x7C7B;&#x4F3C;1/&#x3B1;&#x7684;&#x66F2;&#x7EBF;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x751F;&#x6210;&#x7684;&#x56FE;&#x7247;&#x5728;&#x67D0;&#x4E9B;&#x5730;&#x65B9;&#x770B;&#x8D77;&#x6765;&#x4F1A;&#x8FC7;&#x6697;&#x6216;&#x8FC7;&#x4EAE;</p>
<pre data-role="codeBlock" data-info class="language-"><code>col = vec3( sqrt(col[0]), sqrt(col[1]), sqrt(col[2]) );
</code></pre><p>&#x4EE5;&#x4E0A;&#x4EE3;&#x7801;&#x7684;&#x4F5C;&#x7528;&#x662F;&#x5BF9;&#x989C;&#x8272;&#x4FE1;&#x606F;&#x8FDB;&#x884C;&#x4E00;&#x4E2A;&#x975E;&#x7EBF;&#x6027;&#x7684;&#x6620;&#x5C04;</p>
<hr>
<h3 class="mume-header" id="shadow-acne-problem">shadow acne problem</h3>

<p>&#x4E00;&#x4E9B;&#x5173;&#x4E8E;&#x6B64;&#x95EE;&#x9898;&#x7684;&#x63CF;&#x8FF0;&#x548C;&#x89E3;&#x91CA;</p>
<p><a href="https://www.zhihu.com/question/49090321">zhihu</a></p>
<p><a href="https://computergraphics.stackexchange.com/questions/2192/cause-of-shadow-acne">cause-of-shadow-acne -stackoverflow</a></p>
<pre data-role="codeBlock" data-info class="language-"><code>if (world-&gt;hit(r, 0.001, MAXFLOAT, rec)) {...}
</code></pre><p>&#x89E3;&#x51B3;&#x65B9;&#x6CD5;&#x662F;&#xFF0C;&#x5728;&#x4E0A;&#x9762;&#x8BED;&#x53E5;&#x4E2D;&#xFF0C;&#x5C06;t_min&#x52A0;&#x4E0A;&#x4E00;&#x4E2A;bias&#xFF08;0.001&#xFF09;</p>
<p>&#x6E32;&#x67D3;&#x51FA;&#x7684;&#x56FE;&#x50CF;&#x5BF9;&#x6BD4;</p>
<p><img src="https://pic.downk.cc/item/5e22fcee2fb38b8c3c5d2905.png" alt></p>
<p><img src="https://pic.downk.cc/item/5e22de9e2fb38b8c3c59f22f.png" alt></p>
<hr>
<h3 class="mume-header" id="fuzz">fuzz</h3>

<pre data-role="codeBlock" data-info class="language-"><code>class metal : public material {
    public:
        metal(const vec3&amp; a, float f) : albedo(a) { /*NEW*/
            if (f &lt; 1) fuzz = f; else fuzz = 1;
        }

        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec,
                             vec3&amp; attenuation, ray&amp; scattered) const {
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            scattered = ray(rec.p, reflected + fuzz*random_in_unit_sphere()); /*NEW*/
            attenuation = albedo;
            return (dot(scattered.direction(), rec.normal) &gt; 0);
        }
        vec3 albedo;
        float fuzz; /*NEW*/
};
</code></pre><p>&#x4E3A;metal&#x6750;&#x8D28;&#x6DFB;&#x52A0;&#x6A21;&#x7CCA;&#x6548;&#x679C;</p>
<p>&#x6548;&#x679C;&#x5982;&#x4E0B;&#xFF1A;</p>
<p><img src="https://pic.downk.cc/item/5e2306652fb38b8c3c5e1354.png" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary VII - Dielectrics<br>
date: 2020-01-21</p>
<hr>
<h1 class="mume-header" id="dielectrics">Dielectrics</h1>

<h3 class="mume-header" id="%E6%8A%98%E5%B0%84%E5%90%91%E9%87%8F">&#x6298;&#x5C04;&#x5411;&#x91CF;</h3>

<p>&#x5149;&#x7EBF;&#x7167;&#x5C04;&#x5728;&#x6C34;&#xFF0C;&#x73BB;&#x7483;&#x7B49;&#x7269;&#x4F53;&#x65F6;&#xFF0C;&#x4F1A;&#x53D1;&#x751F;&#x6298;&#x5C04;&#x73B0;&#x8C61;&#xFF0C;&#x5982;&#x56FE;&#x6240;&#x793A;</p>
<p><img src="https://raytracing.github.io/images/fig-1-10-1.jpg" alt></p>
<p>&#x6C42;&#x89E3;&#x6298;&#x5C04;&#x65B9;&#x5411;&#x7684;&#x6B65;&#x9AA4;&#x5982;&#x4E0B;</p>
<p><a href="https://zhuanlan.zhihu.com/p/31127076">&#x7528; C &#x8BED;&#x8A00;&#x753B;&#x5149;&#xFF08;&#x4E94;&#xFF09;&#xFF1A;&#x6298;&#x5C04;</a></p>
<p>&#x8BA1;&#x7B97;&#x6298;&#x5C04;&#x65B9;&#x5411;&#x7684;&#x4EE3;&#x7801;&#x5982;&#x4E0B;</p>
<pre data-role="codeBlock" data-info class="language-"><code>bool refract(const vec3&amp; v, const vec3&amp; n, float ni_over_nt, vec3&amp; refracted) {
    vec3 uv = unit_vector(v);
    float dt = dot(uv, n);
    float discriminant = 1.0 - ni_over_nt*ni_over_nt*(1-dt*dt);
    if (discriminant &gt; 0) {
        refracted = ni_over_nt*(uv - n*dt) - n*sqrt(discriminant);
        return true;
    }
    else
        return false;
}
</code></pre><p>ni_over_nt&#x4E3A;&#x4E24;&#x79CD;&#x4ECB;&#x8D28;&#x6298;&#x5C04;&#x7387;&#x4E4B;&#x6BD4;n1/n2</p>
<hr>
<h3 class="mume-header" id="%E5%8F%8D%E5%B0%84%E7%B3%BB%E6%95%B0">&#x53CD;&#x5C04;&#x7CFB;&#x6570;</h3>

<p>&#x7167;&#x5C04;&#x5230;&#x7269;&#x4F53;&#x4E0A;&#x7684;&#x5149;&#x5E76;&#x4E0D;&#x4F1A;&#x5168;&#x90E8;&#x53D1;&#x751F;&#x6298;&#x5C04;&#xFF0C;&#x6709;&#x4E00;&#x90E8;&#x5206;&#x5149;&#x4F1A;&#x53D1;&#x751F;&#x53CD;&#x5C04;&#xFF0C;&#x8BA1;&#x7B97;&#x53CD;&#x5C04;&#x7A00;&#x758F;&#x7684;&#x4EE3;&#x7801;&#x5982;&#x4E0B;</p>
<pre data-role="codeBlock" data-info class="language-"><code>float schlick(float cosine, float ref_idx) {
    float r0 = (1-ref_idx) / (1+ref_idx);
    r0 = r0*r0;
    return r0 + (1-r0)*pow((1 - cosine),5);
}
</code></pre><p>&#x53C2;&#x8003;</p>
<p><a href="https://zhuanlan.zhihu.com/p/75360639">&#x4ECE;Phong&#x5149;&#x7167;&#x6A21;&#x578B;&#x5230; BRDF</a></p>
<p><a href="https://blog.csdn.net/libing_zeng/article/details/54428732">&#x600E;&#x4E48;&#x6A21;&#x62DF;ray tracing&#x56FE;&#x5F62;&#x4E2D;&#x4ECB;&#x8D28;&#x6750;&#x6599;&#x7684;&#x989C;&#x8272;</a>&#x4E2D;24.1.2 &#x4ECB;&#x8D28;&#x754C;&#x9762;&#x7684;&#x53CD;&#x5C04;&#x7CFB;&#x6570;</p>
<hr>
<h3 class="mume-header" id="%E7%94%B5%E8%A7%A3%E8%B4%A8%E7%B1%BBdeilectric">&#x7535;&#x89E3;&#x8D28;&#x7C7B;deilectric</h3>

<pre data-role="codeBlock" data-info class="language-"><code>class dielectric : public material {
    public:
        dielectric(float ri) : ref_idx(ri) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec,
                             vec3&amp; attenuation, ray&amp; scattered) const {
            vec3 outward_normal;
            vec3 reflected = reflect(r_in.direction(), rec.normal);
            float ni_over_nt;
            attenuation = vec3(1.0, 1.0, 1.0);
            vec3 refracted;

            float reflect_prob;
            float cosine;

            if (dot(r_in.direction(), rec.normal) &gt; 0) {
                 outward_normal = -rec.normal;
                 ni_over_nt = ref_idx;
                 cosine = ref_idx * dot(r_in.direction(), rec.normal)
                        / r_in.direction().length();
            }
            else {
                 outward_normal = rec.normal;
                 ni_over_nt = 1.0 / ref_idx;
                 cosine = -dot(r_in.direction(), rec.normal)
                        / r_in.direction().length();
            }

            if (refract(r_in.direction(), outward_normal, ni_over_nt, refracted)) {
               reflect_prob = schlick(cosine, ref_idx);
            }
            else {
               reflect_prob = 1.0;
            }

            if (random_double() &lt; reflect_prob) {
               scattered = ray(rec.p, reflected);
            }
            else {
               scattered = ray(rec.p, refracted);
            }

            return true;
        }

        float ref_idx;
};
</code></pre><hr>
<p>&#x4FEE;&#x6539;main&#x51FD;&#x6570;</p>
<pre data-role="codeBlock" data-info class="language-"><code>list[0] = new sphere(vec3(0,0,-1), 0.5, new metal(vec3(0.1, 0.2, 0.5),1));
list[1] = new sphere(vec3(0,-100.5,-1), 100, new lambertian(vec3(0.8, 0.8, 0.0)));
list[2] = new sphere(vec3(1,0,-1), 0.5, new metal(vec3(0.8, 0.6, 0.2), 0.3));
list[3] = new sphere(vec3(-1,0,-1), 0.5, new dielectric(1.5));
</code></pre><hr>
<p>&#x6E32;&#x67D3;&#x51FA;&#x7684;&#x56FE;&#x7247;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e2316052fb38b8c3c5fdd85.png" alt></p>
<p>&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#x5DE6;&#x4FA7;&#x7684;&#x7403;&#x4F53;&#x4E2D;&#x50CF;&#x662F;&#x98A0;&#x5012;&#x7684;&#xFF0C;&#x4E0B;&#x9762;&#x8FD9;&#x526F;&#x56FE;&#x53EF;&#x4EE5;&#x7ED9;&#x51FA;&#x4E00;&#x4E2A;&#x89E3;&#x91CA;(&#x56FE;&#x6E90;https://blog.csdn.net/libing_zeng/article/details/54428732)</p>
<p><img src="https://img-blog.csdn.net/20170114205419889?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGliaW5nX3plbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary VIII - Camera<br>
date: 2020-01-22</p>
<hr>
<h1 class="mume-header" id="%E7%9B%B8%E6%9C%BA">&#x76F8;&#x673A;</h1>

<hr>
<h3 class="mume-header" id="%E6%8A%95%E5%BD%B1">&#x6295;&#x5F71;</h3>

<p><img src="https://raytracing.github.io/images/fig-1-11-1.jpg" alt></p>
<p>&#x3B8;&#x662F;&#x53EF;&#x89C6;&#x89D2;&#x5EA6;&#xFF0C;&#x56FE;&#x50CF;&#x7684;&#x9AD8;&#x5EA6; <strong>h=tan(&#x3B8;/2)</strong></p>
<p>&#x6211;&#x4EEC;&#x60F3;&#x8981;&#x6211;&#x4EEC;&#x7684;&#x76F8;&#x673A;&#x5904;&#x4E8E;&#x4EFB;&#x610F;&#x4F4D;&#x7F6E;&#x5E76;&#x53EF;&#x4EE5;&#x6307;&#x5411;&#x4EFB;&#x610F;&#x4F4D;&#x7F6E;&#xFF0C;&#x5373;&#x4ECE; <strong>lookfrom</strong>&#x6307;&#x5411;<strong>lookat</strong></p>
<p><img src="https://raytracing.github.io/images/fig-1-11-2.jpg" alt></p>
<p>&#x6211;&#x4EEC;&#x8981;&#x6C42;&#x5F97;&#x5782;&#x76F4;&#x4E8E; <strong>lookfrom-lookat</strong>&#x5411;&#x91CF;&#x7684;&#x5E73;&#x9762;&#x4E0A;&#x7684;&#x5355;&#x4F4D;&#x5411;&#x91CF; <strong>u</strong>&#xFF0C;<strong>v</strong></p>
<p><img src="https://raytracing.github.io/images/fig-1-11-3.jpg" alt></p>
<p>&#x5DF2;&#x77E5;&#x6709; <strong>vup</strong>&#xFF0C;<strong>lookfrom-lookat</strong>&#x4E24;&#x4E2A;&#x5411;&#x91CF;&#xFF0C;&#x6C42; <strong>u</strong>&#xFF0C;<strong>v</strong>&#x5411;&#x91CF;&#x7684;&#x65B9;&#x5F0F;&#x5982;&#x4E0B;&#xFF1A;</p>
<p><strong>u=cross(vup,lookfrom)</strong></p>
<p><strong>v=cross(u,lookfrom)</strong></p>
<p><strong>u</strong>&#xFF0C;<strong>v</strong>&#x662F;&#x6295;&#x5F71;&#x5E73;&#x9762;&#x6C34;&#x5E73;&#x548C;&#x7AD6;&#x76F4;&#x65B9;&#x5411;&#x7684;&#x6B65;&#x957F;</p>
<hr>
<h3 class="mume-header" id="%E6%99%AF%E6%B7%B1">&#x666F;&#x6DF1;</h3>

<p>&#x5173;&#x4E8E;&#x666F;&#x6DF1;&#x7684;&#x4ECB;&#x7ECD;&#x7B14;&#x8005;&#x4E0D;&#x518D;&#x8D58;&#x8FF0;&#xFF0C;&#x7528;&#x4EE3;&#x7801;&#x6A21;&#x62DF;&#x8FD9;&#x79CD;&#x6548;&#x679C;&#x7684;&#x57FA;&#x672C;&#x601D;&#x60F3;&#x5982;&#x4E0B;&#xFF1A;</p>
<p><img src="https://raytracing.github.io/images/fig-1-12-2.jpg" alt></p>
<p>&#x5173;&#x4E8E;&#x6210;&#x50CF;&#x4F4D;&#x7F6E;&#xFF0C;&#x5F15;&#x5165;&#x53C2;&#x6570;focus_dist&#x4E4B;&#x540E;&#xFF0C;&#x6210;&#x50CF;&#x4F4D;&#x7F6E;&#x5C06;&#x4F1A;&#x662F;-focus_dist*w&#x3002;&#x56FE;&#x7247;&#x7684;&#x9AD8;&#x5BBD;&#x90FD;&#x9700;&#x8981;&#x4E58;&#x4EE5;&#x53C2;&#x6570;focus_dist&#x3002;&#x5149;&#x7EBF;&#x4ECE;&#x955C;&#x5934;&#x5185;&#x7684;&#x968F;&#x673A;&#x4E00;&#x70B9;&#x5C04;&#x51FA;&#xFF0C;&#x6253;&#x5230;&#x7126;&#x5E73;&#x9762;&#x4E0A;</p>
<hr>
<h3 class="mume-header" id="%E7%9B%B8%E6%9C%BA%E7%B1%BB">&#x76F8;&#x673A;&#x7C7B;</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef CAMERAH
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-camerah-1&quot;&gt;&lt;/p&gt;

# define CAMERAH
&lt;p class=&quot;mume-header &quot; id=&quot;define-camerah-1&quot;&gt;&lt;/p&gt;


# include &quot;random.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-randomh-2&quot;&gt;&lt;/p&gt;

# include &quot;ray.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-rayh-4&quot;&gt;&lt;/p&gt;


vec3 random_in_unit_disk() {
    vec3 p;
    do {
        p = 2.0*vec3(random_double(),random_double(),0) - vec3(1,1,0);
    } while (dot(p,p) &gt;= 1.0);
    return p;
}

class camera {
    public:
        camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect,
               float aperture, float focus_dist) {
            lens_radius = aperture / 2;
            float theta = vfov*M_PI/180;
            float half_height = tan(theta/2);
            float half_width = aspect * half_height;
            origin = lookfrom;
            w = unit_vector(lookfrom - lookat);
            u = unit_vector(cross(vup, w));
            v = cross(w, u);
            lower_left_corner = origin
                              - half_width * focus_dist * u
                              - half_height * focus_dist * v
                              - focus_dist * w;
            horizontal = 2*half_width*focus_dist*u;
            vertical = 2*half_height*focus_dist*v;
        }

        ray get_ray(float s, float t) {
            vec3 rd = lens_radius*random_in_unit_disk();
            vec3 offset = u * rd.x() + v * rd.y();
            return ray(origin + offset,
                       lower_left_corner + s*horizontal + t*vertical
                           - origin - offset);
        }

        vec3 origin;
        vec3 lower_left_corner;
        vec3 horizontal;
        vec3 vertical;
        vec3 u, v, w;
        float lens_radius;
};
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-8&quot;&gt;&lt;/p&gt;

</code></pre><p>camera&#x7C7B;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#x4E2D;</p>
<p>lookfrom&#xFF1A;&#x89C2;&#x5BDF;&#x70B9;</p>
<p>lookat&#xFF1A;&#x76EE;&#x6807;&#x70B9;&#xFF0C;&#x5373;&#x89C6;&#x91CE;&#x4E2D;&#x5FC3;</p>
<p>vup&#xFF1A;&#x6444;&#x50CF;&#x673A;&#x7AD6;&#x76F4;&#x4E0A;&#x65B9;</p>
<p>vfov&#xFF1A;&#x53EF;&#x89C6;&#x89D2;&#x5EA6;</p>
<p>aspect&#xFF1A;&#x957F;&#x5BBD;&#x6BD4;</p>
<p>focus_dist&#xFF1A;&#x7126;&#x8DDD;</p>
<p>aperture&#xFF1A;&#x5149;&#x5708;&#x5927;&#x5C0F;</p>
<hr>
<p>&#x4FEE;&#x6539;main&#x51FD;&#x6570;&#x4E2D;&#x4E0B;&#x9762;&#x8BED;&#x53E5;</p>
<pre data-role="codeBlock" data-info class="language-"><code>vec3 lookfrom(3,3,2);
vec3 lookat(0,0,-1);
float dist_to_focus = (lookfrom-lookat).length();
float aperture = 2.0;

camera cam(lookfrom, lookat, vec3(0,1,0), 50,
           float(nx)/float(ny), aperture, dist_to_focus);
</code></pre><p>&#x5C06;&#x89C2;&#x5BDF;&#x70B9;&#x653E;&#x7F6E;&#x5728;(-2,2,1)&#xFF0C;&#x6307;&#x5411;(0,0,-1)&#xFF08;&#x4E2D;&#x95F4;&#x84DD;&#x7403;&#x7684;&#x4E2D;&#x5FC3;&#xFF09;&#xFF0C;y&#x8F74;&#x4E3A;&#x4E0A;&#x65B9;&#xFF0C;&#x53EF;&#x89C6;&#x89D2;&#x5EA6;&#x4E3A;90&#x5EA6;...</p>
<hr>
<p>&#x7ED3;&#x679C;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e25db982fb38b8c3ca6713c.png" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary IX - Next<br>
date: 2020-01-22</p>
<hr>
<h1 class="mume-header" id="%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%9A%84%E6%B8%B2%E6%9F%93">&#x5C01;&#x9762;&#x56FE;&#x7684;&#x6E32;&#x67D3;</h1>

<hr>
<p>&#x4E00;&#x7CFB;&#x5217;&#x968F;&#x673A;&#x7684;&#x7403;&#x4F53;</p>
<pre data-role="codeBlock" data-info class="language-"><code>hittable *random_scene() {
    int n = 500;
    hittable **list = new hittable*[n+1];
    list[0] =  new sphere(vec3(0,-1000,0), 1000, new lambertian(vec3(0.5, 0.5, 0.5)));
    int i = 1;
    for (int a = -11; a &lt; 11; a++) {
        for (int b = -11; b &lt; 11; b++) {
            float choose_mat = random_double();
            vec3 center(a+0.9*random_double(),0.2,b+0.9*random_double());
            if ((center-vec3(4,0.2,0)).length() &gt; 0.9) {
                if (choose_mat &lt; 0.8) {  // diffuse
                    list[i++] = new sphere(center, 0.2,
                        new lambertian(vec3(random_double()*random_double(),
                                            random_double()*random_double(),
                                            random_double()*random_double())
                        )
                    );
                }
                else if (choose_mat &lt; 0.95) { // metal
                    list[i++] = new sphere(center, 0.2,
                            new metal(vec3(0.5*(1 + random_double()),
                                           0.5*(1 + random_double()),
                                           0.5*(1 + random_double())),
                                      0.5*random_double()));
                }
                else {  // glass
                    list[i++] = new sphere(center, 0.2, new dielectric(1.5));
                }
            }
        }
    }

    list[i++] = new sphere(vec3(0, 1, 0), 1.0, new dielectric(1.5));
    list[i++] = new sphere(vec3(-4, 1, 0), 1.0, new lambertian(vec3(0.4, 0.2, 0.1)));
    list[i++] = new sphere(vec3(4, 1, 0), 1.0, new metal(vec3(0.7, 0.6, 0.5), 0.0));

    return new hittable_list(list,i);
}
</code></pre><hr>
<p>&#x4FEE;&#x6539;main&#x51FD;&#x6570;</p>
<pre data-role="codeBlock" data-info class="language-"><code>int main() {

    int nx=600,ny=300,ns=100;
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen(&quot;test.png&quot;, &quot;wb&quot;);

    vec3 lookfrom(0,10,0);
    vec3 lookat(0,0,-1);
    float dist_to_focus = (lookfrom-lookat).length();
    float aperture = 0.01;

    camera cam(lookfrom, lookat, vec3(0,1,0), 50,
           float(nx)/float(ny), aperture, dist_to_focus);
    hittable *world = random_scene();

    for (int j = ny-1; j &gt;= 0; j--){
        for (int i = 0; i &lt; nx; i++) {
            vec3 col(0,0,0);
            for(int s = 0; s &lt; ns ; s++){
                float u = float(i + random_double()) / float(nx);
                float v = float(j + random_double()) / float(ny);
                ray r = cam.get_ray(u,v);               
                col += color(r, world, 0);           
            }
            col /= float(ns);
            col = vec3( sqrt(col[0]), sqrt(col[1]), sqrt(col[2]) );
            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */   
        }
    }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
</code></pre><hr>
<h3 class="mume-header" id="output">output</h3>

<p><img src="https://pic.downk.cc/item/5e26bdf52fb38b8c3cb88f3f.png" alt></p>
<hr>
<h3 class="mume-header" id="next">next</h3>

<ul>
<li>
<p>&#x5149;&#x6E90;</p>
</li>
<li>
<p>&#x7EB9;&#x7406;</p>
</li>
<li>
<p>&#x591A;&#x8FB9;&#x5F62;</p>
</li>
</ul>
<p>-&#x5E76;&#x884C;&#x8BA1;&#x7B97;</p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary X - Bounding Volume Hierarchies<br>
date: 2020-01-23</p>
<hr>
<h1 class="mume-header" id="%E5%B1%82%E6%AC%A1%E5%8C%85%E5%9B%B4%E7%9B%92">&#x5C42;&#x6B21;&#x5305;&#x56F4;&#x76D2;</h1>

<hr>
<p>&#x672C;&#x7AE0;&#x6211;&#x4EEC;&#x91CD;&#x6784;hittable&#x7C7B;&#xFF0C;&#x53EF;&#x4EE5;&#x4F7F;&#x5F97;&#x4EE3;&#x7801;&#x8FD0;&#x884C;&#x7684;&#x66F4;&#x5FEB;&#xFF0C;&#x5728;&#x4E4B;&#x524D;&#x7684;&#x5149;&#x7EBF;&#x8FFD;&#x8E2A;&#x5668;&#x4E2D;&#xFF0C;&#x8BA1;&#x7B97;&#x5149;&#x7EBF;-&#x7269;&#x4F53;&#x76F8;&#x4EA4;&#x662F;&#x6700;&#x8D39;&#x65F6;&#x7684;&#x6B65;&#x9AA4;&#xFF0C;&#x8FD0;&#x7B97;&#x7684;&#x65F6;&#x95F4;&#x548C;&#x7269;&#x4F53;&#x7684;&#x6570;&#x91CF;&#x662F;&#x7EBF;&#x6027;&#x76F8;&#x5173;&#x7684;&#xFF0C;&#x800C;&#x4E14;&#xFF0C;&#x6211;&#x4EEC;&#x7528;&#x4E8C;&#x5206;&#x641C;&#x7D22;&#x7684;&#x601D;&#x60F3;</p>
<p>&#x9996;&#x5148;&#x628A;&#x6A21;&#x578B;&#x5206;&#x4E3A;&#x4E24;&#x7C7B;&#xFF1A;1&#xFF09;&#x5212;&#x5206;&#x7A7A;&#x95F4; 2&#xFF09;&#x5212;&#x5206;&#x5BF9;&#x8C61;</p>
<p>&#x7136;&#x540E;&#xFF0C;&#x6BCF;&#x6761;&#x5149;&#x7EBF;&#x7684;&#x76F8;&#x4EA4;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x6B21;&#x7EBF;&#x6027;&#x641C;&#x7D22;</p>
<p>&#x5BF9;&#x591A;&#x4E2A;&#x7269;&#x4F53;&#xFF0C;&#x7528;bounding volume&#x7684;&#x5173;&#x952E;&#x5C31;&#x662F;&#xFF0C;&#x627E;&#x5230;&#x4E00;&#x4E2A;&#x5305;&#x56F4;&#x4E86;&#x6240;&#x6709;&#x7269;&#x4F53;&#x7684;&#x5305;&#x56F4;&#x76D2;&#xFF0C;&#x5982;&#x679C;&#x5149;&#x7EBF;&#x548C;&#x5305;&#x56F4;&#x76D2;&#x6CA1;&#x6709;&#x4EA4;&#x70B9;&#xFF0C;&#x90A3;&#x5149;&#x7EBF;&#x548C;&#x8FD9;&#x4E9B;&#x7269;&#x4F53;&#x90FD;&#x4E0D;&#x76F8;&#x4EA4;&#xFF0C;&#x5224;&#x65AD;&#x78B0;&#x649E;&#x7684;&#x4F2A;&#x4EE3;&#x7801;&#x5982;&#x4E0B;</p>
<pre data-role="codeBlock" data-info class="language-"><code>if (ray hits bounding object)
    return whether ray hits bounded objects
else
    return false
</code></pre><p>&#x5982;&#x4E0A;&#x56FE;&#xFF0C;&#x6BCF;&#x4E00;&#x4E2A;&#x7269;&#x4F53;&#x90FD;&#x6709;&#x4E00;&#x4E2A;bounding volume&#xFF0C;&#x591A;&#x4E2A;&#x7269;&#x4F53;&#x7684;bounding volume&#x76F8;&#x4E92;&#x53E0;&#x52A0;&#xFF0C;&#x5C31;&#x5F62;&#x6210;&#x4E86;&#x4E00;&#x4E2A;&#x6709;&#x5C42;&#x7EA7;&#x5173;&#x7CFB;&#x7684;bounding volume&#xFF0C;</p>
<p><img src="https://raytracing.github.io/images/fig-2-3-01.jpg" alt></p>
<p>&#x5BF9;&#x6B64;&#x5C42;&#x7EA7;&#x68C0;&#x6D4B;&#x78B0;&#x649E;&#x7684;&#x4F2A;&#x4EE3;&#x7801;&#x4E3A;</p>
<pre data-role="codeBlock" data-info class="language-"><code>if(hit purple) //&#x7D2B;&#x8272;
    hit0 = hits blue enclosed objects
    hit1 = hits red enclosed objects
    if(hit0 or hit1)
        return true and info of closer hit //&#x8FD4;&#x56DE;hit&#x7684;&#x4FE1;&#x606F;
else
    return false
</code></pre><p>&#x5728;&#x5B9E;&#x9645;&#x64CD;&#x4F5C;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x91C7;&#x7528;&#x4E0E;&#x5750;&#x6807;&#x8F74;&#x5E73;&#x884C;&#x7684;&#x957F;&#x65B9;&#x4F53;&#xFF08;axis-aligned bounding rectangular parallelepiped&#xFF09;&#x4F5C;&#x4E3A;&#x5305;&#x56F4;&#x76D2;&#xFF0C;&#x6216;&#x53EB;&#x505A;aabbs&#xFF0C;&#x6211;&#x4EEC;&#x53EA;&#x7528;&#x68C0;&#x6D4B;&#x5149;&#x7EBF;&#x662F;&#x5426;&#x4E0E;&#x5305;&#x56F4;&#x76D2;&#x76F8;&#x4EA4;&#xFF0C;&#x800C;&#x4E0D;&#x7528;&#x5F97;&#x77E5;&#x4EA4;&#x70B9;&#x7684;&#x5177;&#x4F53;&#x4FE1;&#x606F;</p>
<p>&#x4EE5;2D&#x5E73;&#x9762;&#x4E3A;&#x4F8B;</p>
<p><strong>p(t)= a+t*b</strong></p>
<p>x&#x8F74;&#x4E0A;</p>
<p><strong>x0=ax0+t0&#x2217;bx0</strong></p>
<p><strong>x1=ax1+t1&#x2217;bx1</strong></p>
<p>&#x89E3;&#x5F97;&#xFF1A;</p>
<p><strong>t0=(x0-ax0)/bx0</strong></p>
<p><strong>t1=(x1-ax1)/bx1</strong></p>
<p>&#x540C;&#x7406;&#xFF0C;&#x5728;y&#x8F74;&#x4E0A;</p>
<p><strong>t0=(y0-ay0)/by0</strong></p>
<p><strong>t1=(y1-ay1)/by1</strong></p>
<p>x&#xFF0C;y&#x662F;&#x5206;&#x5F00;&#x8BA1;&#x7B97;&#x7684;&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#xFF0C;&#x5224;&#x65AD;x&#xFF0C;y&#x8F74;&#x7684;(t0,t1)&#x6709;&#x6CA1;&#x6709;&#x76F8;&#x4EA4;&#x7684;&#x90E8;&#x5206;&#x5373;&#x53EF;</p>
<p>&#x5224;&#x65AD;&#x7684;&#x65B9;&#x6CD5;&#x5982;&#x4E0B;&#xFF1A;</p>
<p><img src="https://raytracing.github.io/images/fig-2-3-04.jpg" alt></p>
<pre class="language-text">&#x4E24;&#x4E2A;&#x533A;&#x95F4;&#x7684;&#x5DE6;&#x7AEF;&#x70B9;&#x6700;&#x5927;&#x503C;&#x5C0F;&#x4E8E;&#x53F3;&#x7AEF;&#x70B9;&#x7684;&#x6700;&#x5C0F;&#x503C;
&#x3000;&#x3000;&#x6709;&#x4EA4;&#x70B9;
&#x53CD;&#x4E4B;
&#x3000;&#x3000;&#x65E0;&#x4EA4;&#x70B9;
</pre>
<p>&#x6CE8;&#x610F;&#xFF1A;</p>
<p>1&#xFF09;&#x76F4;&#x63A5;&#x8BA1;&#x7B97;&#x51FA;&#x6765;&#x7684;t0&#xFF0C;t1&#x5927;&#x5C0F;&#x4E0D;&#x786E;&#x5B9A;&#xFF0C;&#x9700;&#x8981;&#x5148;&#x5224;&#x65AD;&#xFF0C;&#x8C03;&#x6574;&#x5927;&#x5C0F;&#x4F7F;t0 &lt; t1</p>
<p>2&#xFF09;&#x5982;&#x679C;&#x9664;&#x6570;Bx=0&#xFF0C;&#x6216;&#x8005;&#x5206;&#x5B50;&#x662F;0&#xFF0C;&#x6C42;&#x51FA;&#x6765;&#x7684;&#x89E3;&#x4E5F;&#x8BB8;&#x65E0;&#x610F;&#x4E49;&#xFF0C;&#x9700;&#x8981;&#x63D0;&#x524D;&#x68C0;&#x6D4B;</p>
<h3 class="mume-header" id="aabbh">aabb.h</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef AABB
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-aabb&quot;&gt;&lt;/p&gt;

# define AABB 
&lt;p class=&quot;mume-header &quot; id=&quot;define-aabb&quot;&gt;&lt;/p&gt;


# include &quot;hittable.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-hittableh-3&quot;&gt;&lt;/p&gt;

# include &quot;ray.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-rayh-5&quot;&gt;&lt;/p&gt;


//faster than fmin and fmax because it doesn&#x2019;t worry about NaNs and other exceptions
inline float ffmin(float a, float b) { return a &lt; b ? a : b; }
inline float ffmax(float a, float b) { return a &gt; b ? a : b; }

class aabb {
    public:
        aabb() {}
        aabb(const vec3&amp; a, const vec3&amp; b) { _min = a; _max = b;}
        vec3 min() const {return _min; }
        vec3 max() const {return _max; }
        virtual bool hit(const ray&amp; r, float tmin, float tmax) const;

        vec3 _min;
        vec3 _max;
};

inline bool aabb::hit(const ray&amp; r, float tmin, float tmax) const {
    for (int a = 0; a &lt; 3; a++) {
        float invD = 1.0f / r.direction()[a];
        float t0 = (min()[a] - r.origin()[a]) * invD;
        float t1 = (max()[a] - r.origin()[a]) * invD;
        if (invD &lt; 0.0f)
            std::swap(t0, t1);
        tmin = t0 &gt; tmin ? t0 : tmin;
        tmax = t1 &lt; tmax ? t1 : tmax;
        if (tmax &lt;= tmin)
            return false;
    }
    return true;
}
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-9&quot;&gt;&lt;/p&gt;

</code></pre><p>&#x63A5;&#x4E0B;&#x6765;&#x6211;&#x4EEC;&#x5728;hittable.h&#x4E2D;&#x6DFB;&#x52A0;bounding_box&#x7EAF;&#x865A;&#x51FD;&#x6570;&#xFF0C;&#x8FD9;&#x6837;&#xFF0C;&#x5728;&#x6BCF;&#x4E2A;&#x7269;&#x4F53;&#x5728;&#x8BA1;&#x7B97;&#x65F6;&#x90FD;&#x4F1A;&#x6709;&#x4E00;&#x4E2A;&#x5305;&#x56F4;&#x76D2;&#x4E86;</p>
<pre data-role="codeBlock" data-info class="language-"><code>class hittable {
    public:
        virtual bool hit(
            const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const = 0;
        virtual bool bounding_box(float t0, float t1, aabb&amp; box) const = 0;
};
</code></pre><p>sphere&#x7684;&#x5305;&#x56F4;&#x76D2;&#xFF1A;&#x7403;&#x5FC3;&#x52A0;&#x534A;&#x5F84;</p>
<pre data-role="codeBlock" data-info class="language-"><code>bool sphere::bounding_box(float t0, float t1, aabb&amp; box) const {
    box = aabb(center - vec3(radius, radius, radius),
               center + vec3(radius, radius, radius));
    return true;
}
</code></pre><p>moving sphere&#x7684;&#x5305;&#x56F4;&#x76D2;&#xFF1A;&#x5BF9;t0&#x65F6;&#x523B;&#x7684;box&#x548C;t1&#x65F6;&#x523B;&#x7684;box&#xFF0C;&#x53D6;&#x4E00;&#x4E2A;&#x66F4;&#x5927;&#x7684;boundingbox</p>
<pre data-role="codeBlock" data-info class="language-"><code>bool moving_sphere::bounding_box(float t0, float t1, aabb&amp; box) const {
    aabb box0(center(t0) - vec3(radius, radius, radius),
              center(t0) + vec3(radius, radius, radius));
    aabb box1(center(t1) - vec3(radius, radius, radius),
              center(t1) + vec3(radius, radius, radius));
    box = surrounding_box(box0, box1);
    return true;
}
</code></pre><p>hittable_list&#x7684;&#x5305;&#x56F4;&#x76D2;&#xFF1A;&#x5BF9;list&#x7684;&#x6BCF;&#x4E2A;&#x7269;&#x4F53;&#x8BA1;&#x7B97;surrounding_box&#xFF0C;&#x5E76;&#x53E0;&#x52A0;&#xFF0C;&#x6700;&#x7EC8;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5305;&#x542B;&#x6240;&#x6709;&#x7269;&#x4F53;&#x7684;&#x5305;&#x56F4;&#x76D2;</p>
<pre data-role="codeBlock" data-info class="language-"><code>bool hittable_list::bounding_box(float t0, float t1, aabb&amp; box) const {
    if (list_size &lt; 1) return false;
    aabb temp_box;
    bool first_true = list[0]-&gt;bounding_box(t0, t1, temp_box);
    if (!first_true)
        return false;
    else
        box = temp_box;
    for (int i = 1; i &lt; list_size; i++) {
        if(list[i]-&gt;bounding_box(t0, t1, temp_box)) {
            box = surrounding_box(box, temp_box);
        }
        else
            return false;
    }
    return true;
}
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>//&#x4E24;&#x4E2A;&#x5305;&#x56F4;&#x76D2;&#x53E0;&#x52A0;&#x751F;&#x6210;&#x7684;&#x5305;&#x56F4;&#x76D2;
aabb surrounding_box(aabb box0, aabb box1) {
    vec3 small( ffmin(box0.min().x(), box1.min().x()),
                ffmin(box0.min().y(), box1.min().y()),
                ffmin(box0.min().z(), box1.min().z()));
    vec3 big  ( ffmax(box0.max().x(), box1.max().x()),
                ffmax(box0.max().y(), box1.max().y()),
                ffmax(box0.max().z(), box1.max().z()));
    return aabb(small,big);
}
</code></pre><h3 class="mume-header" id="bvhh">bvh.h</h3>

<pre data-role="codeBlock" data-info class="language-"><code>class bvh_node : public hittable {
    public:
        bvh_node() {}
        bvh_node(hittable **l, int n, float time0, float time1);
        virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const;
        virtual bool bounding_box(float t0, float t1, aabb&amp; box) const;

        hittable *left;
        hittable *right;
        aabb box;
};

bool bvh_node::bounding_box(float t0, float t1, aabb&amp; b) const {
    b = box;
    return true;
}

</code></pre><p>hit&#x51FD;&#x6570;&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x5149;&#x7EBF;&#x51FB;&#x4E2D;&#x4E86;&#x8282;&#x70B9;&#x7684;&#x5305;&#x56F4;&#x76D2;&#xFF0C;&#x5BF9;&#x4E8E;&#x5DE6;&#x53F3;&#x5B50;&#x6811;&#x8FDB;&#x884C;&#x9012;&#x5F52;&#x64CD;&#x4F5C;&#xFF0C;&#x76F4;&#x5230;&#x5C04;&#x5230;&#x53F6;&#x5B50;&#x8282;&#x70B9;&#xFF0C;&#x51FB;&#x4E2D;&#x91CD;&#x53E0;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x51FB;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x7528;&#x5F15;&#x7528;rec&#x4F20;&#x51FA;&#x53BB;&#x3002;</p>
<pre data-role="codeBlock" data-info class="language-"><code>bool bvh_node::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    if (box.hit(r, t_min, t_max)) {
        hit_record left_rec, right_rec;
        bool hit_left = left-&gt;hit(r, t_min, t_max, left_rec);
        bool hit_right = right-&gt;hit(r, t_min, t_max, right_rec);
        if (hit_left &amp;&amp; hit_right) {
            if (left_rec.t &lt; right_rec.t)
                rec = left_rec;
            else
                rec = right_rec;
            return true;
        }
        else if (hit_left) {
            rec = left_rec;
            return true;
        }
        else if (hit_right) {
            rec = right_rec;
            return true;
        }
        else
            return false;
    }
    else return false;
}

</code></pre><p>&#x6211;&#x4EEC;&#x8981;&#x5C06;&#x5BF9;&#x8C61;&#x5217;&#x8868;bvh_node&#x5206;&#x4E3A;&#x4E24;&#x4E2A;&#x5B50;&#x5217;&#x8868;&#xFF0C;&#x5982;&#x679C;&#x5212;&#x5206;&#x5F97;&#x5F88;&#x597D;&#xFF0C;&#x4EE3;&#x7801;&#x7684;&#x8FD0;&#x884C;&#x901F;&#x5EA6;&#x5C31;&#x4F1A;&#x5FEB;&#x5F88;&#x591A;&#xFF0C;&#x6700;&#x4F73;&#x662F;&#x6EE1;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x60C5;&#x51B5;&#xFF0C;&#x6B65;&#x9AA4;&#x5982;&#x4E0B;&#xFF1A;</p>
<pre class="language-text">&#x968F;&#x673A;&#x9009;&#x62E9;&#x4E00;&#x4E2A;&#x8F74;
&#x4F7F;&#x7528;qsort&#x5BF9;&#x7269;&#x4F53;&#x8FDB;&#x884C;&#x6392;&#x5E8F;
&#x5728;&#x6BCF;&#x4E2A;&#x5B50;&#x6811;&#x4E2D;&#x653E;&#x4E00;&#x534A;&#x7269;&#x4F53;
</pre>
<pre data-role="codeBlock" data-info class="language-"><code>bvh_node::bvh_node(hittable **l, int n, float time0, float time1) {
    int axis = int(3*random_double());

    if (axis == 0)
       qsort(l, n, sizeof(hittable *), box_x_compare);
    else if (axis == 1)
       qsort(l, n, sizeof(hittable *), box_y_compare);
    else
       qsort(l, n, sizeof(hittable *), box_z_compare);

    if (n == 1) {
        left = right = l[0];
    }
    else if (n == 2) {
        left = l[0];
        right = l[1];
    }
    else {
        left = new bvh_node(l, n/2, time0, time1);
        right = new bvh_node(l + n/2, n - n/2, time0, time1);
    }

    aabb box_left, box_right;

    if (!left-&gt;bounding_box(time0, time1, box_left) ||
        !right-&gt;bounding_box(time0, time1, box_right)) {

        std::cerr &lt;&lt; &quot;no bounding box in bvh_node constructor\n&quot;;
    }

    box = surrounding_box(box_left, box_right);
}
</code></pre><p>compare&#x51FD;&#x6570;</p>
<pre data-role="codeBlock" data-info class="language-"><code>int box_x_compare (const void * a, const void * b) {
    aabb box_left, box_right;
    hittable *ah = *(hittable**)a;
    hittable *bh = *(hittable**)b;

    if (!ah-&gt;bounding_box(0,0, box_left) || !bh-&gt;bounding_box(0,0, box_right))
        std::cerr &lt;&lt; &quot;no bounding box in bvh_node constructor\n&quot;;

    if (box_left.min().x() - box_right.min().x() &lt; 0.0)
        return -1;
    else
        return 1;
}

int box_y_compare (const void * a, const void * b) {
    aabb box_left, box_right;
    hittable *ah = *(hittable**)a;
    hittable *bh = *(hittable**)b;

    if (!ah-&gt;bounding_box(0,0, box_left) || !bh-&gt;bounding_box(0,0, box_right))
        std::cerr &lt;&lt; &quot;no bounding box in bvh_node constructor\n&quot;;

    if (box_left.min().y() - box_right.min().y() &lt; 0.0)
        return -1;
    else
        return 1;
}

int box_z_compare (const void * a, const void * b) {
    aabb box_left, box_right;
    hittable *ah = *(hittable**)a;
    hittable *bh = *(hittable**)b;

    if (!ah-&gt;bounding_box(0,0, box_left) || !bh-&gt;bounding_box(0,0, box_right))
        std::cerr &lt;&lt; &quot;no bounding box in bvh_node constructor\n&quot;;

    if (box_left.min().z() - box_right.min().z() &lt; 0.0)
        return -1;
    else
        return 1;
}
</code></pre><hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary XI - Textures<br>
date: 2020-01-24</p>
<hr>
<h1 class="mume-header" id="%E7%BA%B9%E7%90%86">&#x7EB9;&#x7406;</h1>

<hr>
<h3 class="mume-header" id="%E7%BA%B9%E7%90%86%E7%B1%BB">&#x7EB9;&#x7406;&#x7C7B;</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef TEXTURE
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-texture&quot;&gt;&lt;/p&gt;

# define TEXTURE 
&lt;p class=&quot;mume-header &quot; id=&quot;define-texture&quot;&gt;&lt;/p&gt;



class texture {
    public:
        virtual vec3 value(float u, float v, const vec3&amp; p) const = 0;
};

//&#x7EAF;&#x8272;&#x7EB9;&#x7406;
class constant_texture : public texture {
    public:
        constant_texture() {}
        constant_texture(vec3 c) : color(c) {}
        virtual vec3 value(float u, float v, const vec3&amp; p) const {
            return color;
        }
        vec3 color;
};

//&#x68CB;&#x76D8;&#x7EB9;&#x7406;
class checker_texture : public texture {
    public:
        checker_texture() {}
        checker_texture(texture *t0, texture *t1): even(t0), odd(t1) {}
        virtual vec3 value(float u, float v, const vec3&amp; p) const {
            float sines = sin(10*p.x())*sin(10*p.y())*sin(10*p.z());
            if (sines &lt; 0)
                return odd-&gt;value(u, v, p);
            else
                return even-&gt;value(u, v, p);
        }
        texture *odd;
        texture *even;
};

# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-10&quot;&gt;&lt;/p&gt;

</code></pre><p>&#x4FEE;&#x6539;&#x6750;&#x8D28;&#x7C7B;&#x4E2D;&#x76F8;&#x5173;&#x4EE3;&#x7801;</p>
<pre data-role="codeBlock" data-info class="language-"><code>class lambertian : public material {
    public:
        lambertian(texture *a) : albedo(a) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec,
                             vec3&amp; attenuation, ray&amp; scattered) const {
            vec3 target = rec.p + rec.normal + random_in_unit_sphere();
            scattered = ray(rec.p, target - rec.p);
            attenuation = albedo-&gt;value(0, 0, rec.p);
            return true;
        }
        texture *albedo;
};
</code></pre><p>&#x5728;&#x7EAF;&#x8272;&#x7EB9;&#x7406;&#x4E2D;&#xFF0C;value&#x51FD;&#x6570;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x6240;&#x63A5;&#x53D7;&#x7684;vec3 p&#x7684;&#x989C;&#x8272;&#x503C;</p>
<p>&#x5728;&#x68CB;&#x76D8;&#x7EB9;&#x7406;&#x4E2D;&#xFF0C;value&#x51FD;&#x6570;&#x6839;&#x636E;p&#x7684;xyz&#x5750;&#x6807;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x5468;&#x671F;&#x6027;&#x7684;&#x4E8C;&#x503C;&#x989C;&#x8272;&#xFF0C;&#x7528;&#x4E09;&#x89D2;&#x51FD;&#x6570;&#x5B9E;&#x73B0;&#x662F;&#x4E00;&#x4E2A;&#x4E0D;&#x9519;&#x7684;&#x9009;&#x62E9;</p>
<hr>
<h3 class="mume-header" id="examples">Examples</h3>

<p>&#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#x5B9A;&#x4E49;&#x4E86;&#x7EAF;&#x8272;&#x548C;&#x68CB;&#x76D8;&#x4E24;&#x79CD;&#x4E0D;&#x540C;&#x7684;&#x6750;&#x8D28;</p>
<pre data-role="codeBlock" data-info class="language-"><code>hittable *two_spheres() {
    texture *checker = new checker_texture(
        new constant_texture(vec3(0.2, 0.3, 0.1)),
        new constant_texture(vec3(0.9, 0.9, 0.9))
    );
    texture* simple=new constant_texture(vec3(0.5,0.5,0.5));


    int n = 50;
    hittable **list = new hittable*[n+1];
    list[0] = new sphere(vec3(0,-10, 0), 10, new lambertian(checker));
    list[1] = new sphere(vec3(0, 10, 0), 10, new lambertian(simple));
    return new hittable_list(list,2);
}
</code></pre><hr>
<h3 class="mume-header" id="%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B">&#x7ED3;&#x679C;&#x5982;&#x4E0B;</h3>

<p><img src="https://pic.downk.cc/item/5e2a655a2fb38b8c3c5a145a.png" alt></p>
<hr>
<h3 class="mume-header" id="%E6%B8%90%E5%8F%98%E8%89%B2%E7%BA%B9%E7%90%86">&#x6E10;&#x53D8;&#x8272;&#x7EB9;&#x7406;</h3>

<p>&#x987A;&#x624B;&#x5199;&#x4E86;&#x4E00;&#x4E2A;&#x6839;&#x636E;&#x4EA4;&#x70B9;&#x5750;&#x6807;&#x6E32;&#x67D3;&#x6E10;&#x53D8;&#x989C;&#x8272;&#x7684;&#x7EB9;&#x7406;</p>
<pre data-role="codeBlock" data-info class="language-"><code>class rainbow_texture:public texture
{
public:
    rainbow_texture(){};
    virtual vec3 value(float u,float v,const vec3&amp; p)const{
        return vec3(fabs(sin(p.x())),fabs(sin(p.y())),fabs(sin(p.z())));
    }
    ~rainbow_texture();
};
</code></pre><hr>
<p>&#x6E32;&#x67D3;  &#x7ED3;&#x679C;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e2a86032fb38b8c3c5c4176.png" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary XII - Perlin Noise<br>
date: 2020-01-25</p>
<hr>
<p>&#x7531;&#x7A0B;&#x5E8F;&#x4EA7;&#x751F;&#x566A;&#x58F0;&#x7684;&#x65B9;&#x6CD5;&#x5927;&#x81F4;&#x53EF;&#x4EE5;&#x5206;&#x4E3A;&#x4E24;&#x7C7B;&#xFF1A;</p>
<ul>
<li>
<p>&#x57FA;&#x4E8E;&#x6676;&#x683C;&#x7684;&#x65B9;&#x6CD5;&#xFF08;Lattice based&#xFF09;&#x53C8;&#x53EF;&#x7EC6;&#x5206;&#x4E3A;&#x4E24;&#x79CD;&#xFF1A;<br>
&#x7B2C;&#x4E00;&#x79CD;&#x662F;&#x68AF;&#x5EA6;&#x566A;&#x58F0;&#xFF08;Gradient noise&#xFF09;&#xFF0C;&#x5305;&#x62EC;Perlin noise&#xFF0C;Simplex noise&#xFF0C;Wavelet noise&#x7B49;<br>
&#x7B2C;&#x4E8C;&#x79CD;&#x662F;Value noise&#x3002;</p>
</li>
<li>
<p>&#x57FA;&#x4E8E;&#x70B9;&#x7684;&#x65B9;&#x6CD5;&#xFF08;Point based&#xFF09;<br>
Worley noise</p>
</li>
</ul>
<hr>
<p>&#x4E0B;&#x56FE;&#x662F;&#x6211;&#x4EEC;&#x5E38;&#x89C1;&#x7684;&#x767D;&#x566A;&#x58F0;&#x56FE;&#x50CF;</p>
<p><img src="https://raytracing.github.io/images/img-2-5-01.jpg" alt></p>
<p>&#x68AF;&#x5EA6;&#x566A;&#x58F0;&#x4EA7;&#x751F;&#x7684;&#x7EB9;&#x7406;&#x5177;&#x6709;&#x8FDE;&#x7EED;&#x6027;&#xFF0C;&#x56E0;&#x4E3A;&#x5728;&#x5176;&#x566A;&#x58F0;&#x4E0E;&#x76F8;&#x90BB;&#x70B9;&#x566A;&#x58F0;&#x7684;&#x52A0;&#x6743;&#x6709;&#x5173;&#xFF0C;&#x6240;&#x4EE5;&#x7ECF;&#x5E38;&#x7528;&#x6765;&#x6A21;&#x62DF;&#x5C71;&#x8109;&#x3001;&#x4E91;&#x6735;&#x7B49;&#x5177;&#x6709;&#x8FDE;&#x7EED;&#x6027;&#x7684;&#x7269;&#x8D28;&#xFF0C;perlin noise&#xFF0C;&#x5176;&#x5B83;&#x68AF;&#x5EA6;&#x566A;&#x58F0;&#x8FD8;&#x6709;Simplex Noise&#x548C;Wavelet Noise&#xFF0C;&#x5B83;&#x4EEC;&#x4E5F;&#x662F;&#x7531;Perlin Noise&#x6F14;&#x53D8;&#x800C;&#x6765;</p>
<p>Perlin Noise&#x8FD4;&#x56DE;&#x5982;&#x4E0B;&#x6240;&#x793A;&#x7684;&#x56FE;&#x50CF;&#xFF0C;&#x662F;&#x4E00;&#x4E2A;&#x5177;&#x6709;&#x6A21;&#x7CCA;&#x6548;&#x679C;&#x7684;&#x566A;&#x58F0;&#x56FE;</p>
<p><img src="https://raytracing.github.io/images/img-2-5-02.jpg" alt></p>
<hr>
<h3 class="mume-header" id="%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4">&#x7B97;&#x6CD5;&#x6B65;&#x9AA4;</h3>

<p>&#x751F;&#x6210;perlin noise&#x7684;&#x6B65;&#x9AA4;&#x5982;&#x4E0B;&#xFF1A;</p>
<ul>
<li>
<p>&#x7ED9;&#x5B9A;&#x70B9;&#x8F93;&#x5165;&#x70B9;p</p>
</li>
<li>
<p>&#x5BF9;&#x4E8E;&#x6BCF;&#x4E00;&#x4E2A;&#x4E0E;&#x70B9;p&#x76F8;&#x90BB;&#x7684;&#x65B9;&#x683C;&#x7AEF;&#x70B9;&#xFF08;&#x4E8C;&#x7EF4;&#x7684;&#x566A;&#x58F0;&#x5C31;&#x662F;4&#x4E2A;&#x70B9;&#xFF0C;&#x4E09;&#x7EF4;&#x566A;&#x58F0;&#x5C31;&#x662F;8&#x4E2A;&#x70B9;&#xFF09;</p>
</li>
<li>
<p>&#x6311;&#x9009;&#x4E00;&#x4E2A;&#x4F2A;&#x968F;&#x673A;&#x68AF;&#x5EA6;&#x5411;&#x91CF;</p>
</li>
<li>
<p>&#x8BA1;&#x7B97;&#x968F;&#x673A;&#x5411;&#x91CF;&#x548C;&#x8DDD;&#x79BB;&#x7684;&#x70B9;&#x79EF;</p>
</li>
<li>
<p>&#x6BCF;&#x4E2A;&#x7EF4;&#x5EA6;&#x4E0A;&#xFF0C;&#x5747;&#x91C7;&#x7528;&#x7F13;&#x548C;&#x66F2;&#x7EBF;&#xFF0C;&#x8BA1;&#x7B97;&#x51FA;&#x52A0;&#x6743;&#x5E73;&#x5747;&#x503C;&#xFF0C;&#x7F13;&#x548C;&#x66F2;&#x7EBF;&#x53EF;&#x4EE5;&#x9009;&#x7528;3*t<sup>3-2*t</sup>3</p>
</li>
</ul>
<p>&#x5177;&#x4F53;&#x63A8;&#x5BFC;&#x53EF;&#x89C1;&#x4E0B;&#x9762;&#x51E0;&#x7BC7;&#x6587;&#x7AE0;&#x4EE5;&#x53CA;pen perlin&#x7684;&#x8BBA;&#x6587;</p>
<p><a href="https://blog.csdn.net/qq_34302921/article/details/80849139"></a></p>
<p><a href="http://www.twinklingstar.cn/2015/2581/classical-perlin-noise/#2_Perlin"></a></p>
<hr>
<h3 class="mume-header" id="perlinh">perlin.h</h3>

<pre data-role="codeBlock" data-info class="language-"><code>static vec3* perlin_generate() {
    vec3 *p = new vec3[256];
    for (int i = 0; i &lt; 256; ++i) {
        double x_random = 2*random_double() - 1;
        double y_random = 2*random_double() - 1;
        double z_random = 2*random_double() - 1;
        p[i] = unit_vector(vec3(x_random, y_random, z_random));
    }
    return p;
}
</code></pre><p>perlin_generate&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x957F;&#x5EA6;&#x4E3A;1&#x7684;&#x968F;&#x673A;vec3&#x6570;&#x7EC4;</p>
<pre data-role="codeBlock" data-info class="language-"><code>void permute(int *p, int n) {
    for (int i = n-1; i &gt; 0; i--) {
        int target = int(random_double()*(i+1));
        int tmp = p[i];
        p[i] = p[target];
        p[target] = tmp;
    }
    return;
}
</code></pre><p>&#x6253;&#x4E71;&#x6570;&#x7EC4;p&#x7684;&#x987A;&#x5E8F;&#xFF0C;&#x7ECF;&#x6D4B;&#x8BD5;&#xFF0C;std::random_shuffle&#x4E5F;&#x53EF;&#x4EE5;&#x8FBE;&#x5230;&#x540C;&#x6837;&#x7684;&#x6548;&#x679C;</p>
<pre data-role="codeBlock" data-info class="language-"><code>static int* perlin_generate_perm() {
    int * p = new int[256];
    for (int i = 0; i &lt; 256; i++)
        p[i] = i;
    permute(p, 256);
    return p;
}
</code></pre><p>perlin_generate_perm&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x4E71;&#x5E8F;&#x65E0;&#x91CD;&#x590D;&#x7684;&#x4ECE;0~255&#x7684;&#x6570;&#x7EC4;</p>
<pre data-role="codeBlock" data-info class="language-"><code>inline float perlin_interp(vec3 c[2][2][2], float u, float v, float w) {
    //&#x7F13;&#x548C;&#x66F2;&#x7EBF;
    float uu = u*u*(3-2*u);
    float vv = v*v*(3-2*v);
    float ww = w*w*(3-2*w);
    float accum = 0;
    for (int i=0; i &lt; 2; i++)
        for (int j=0; j &lt; 2; j++)
            for (int k=0; k &lt; 2; k++) {
                vec3 weight_v(u-i, v-j, w-k);
                //&#x4E09;&#x7EF4;&#x7EBF;&#x6027;&#x63D2;&#x503C;*&#x6743;&#x91CD;*&#x68AF;&#x5EA6;
                accum += (i*uu + (1-i)*(1-uu))*
                    (j*vv + (1-j)*(1-vv))*
                    (k*ww + (1-k)*(1-ww))*dot(c[i][j][k], weight_v);
            }
    return accum;
}
</code></pre><p>perlin&#x7C7B;</p>
<pre data-role="codeBlock" data-info class="language-"><code>class perlin {
    public:
        float noise(const vec3&amp; p) const;
        static vec3 *ranvec;
        static int *perm_x;
        static int *perm_y;
        static int *perm_z;
};

vec3* perlin::ranvec = perlin_generate();//&#x968F;&#x673A;&#x5411;&#x91CF;
int *perlin::perm_x = perlin_generate_perm();//&#x968F;&#x673A;&#x6570;&#x7EC4;
int *perlin::perm_y = perlin_generate_perm();//&#x968F;&#x673A;&#x6570;&#x7EC4;
int *perlin::perm_z = perlin_generate_perm();//&#x968F;&#x673A;&#x6570;&#x7EC4;

float perlin::noise(const vec3&amp; p) const {
    float u = p.x() - floor(p.x());
    float v = p.y() - floor(p.y());
    float w = p.z() - floor(p.z());

    int i = floor(p.x());
    int j = floor(p.y());
    int k = floor(p.z());

    vec3 c[2][2][2];
    //&#x6311;&#x9009;p&#x4E34;&#x8FD1;8&#x4E2A;&#x70B9;&#x7684;&#x968F;&#x673A;&#x5411;&#x91CF;
    for (int di=0; di &lt; 2; di++)
        for (int dj=0; dj &lt; 2; dj++)
            for (int dk=0; dk &lt; 2; dk++)
                //&#x53EA;&#x4FDD;&#x7559;&#x540E;8&#x4F4D;
                c[di][dj][dk] = ranvec[perm_x[(i+di) &amp; 255] ^ perm_y[(j+dj) &amp; 255] ^ perm_z[(k+dk) &amp; 255] ];

    return perlin_interp(c, u, v, w);
}
</code></pre><p>perlin_noise&#x6750;&#x8D28;</p>
<pre data-role="codeBlock" data-info class="language-"><code>class noise_texture : public texture {
    public:
        noise_texture() {}
        noise_texture(float sc) : scale(sc) {}
        virtual vec3 value(float u, float v, const vec3&amp; p) const {
            return vec3(1,1,1) * noise.noise(scale*p);
        }

        perlin noise;
        float scale;
};
</code></pre><p>noise_texture&#x63A5;&#x53D7;&#x4E00;&#x4E2A;scale&#x503C;&#xFF0C;scale&#x8D8A;&#x5927;&#xFF0C;&#x566A;&#x58F0;&#x7EB9;&#x7406;&#x8D8A;&#x5BC6;</p>
<hr>
<h3 class="mume-header" id="test">test</h3>

<pre data-role="codeBlock" data-info class="language-"><code>hittable *two_perlin_spheres() {
    texture* pertext = new noise_texture(10);
    texture* simple=new constant_texture(vec3(0.0,0.0,0.0));
    hittable **list = new hittable*[2];
    list[0] = new sphere(vec3(0,-1000, 0), 1000, new lambertian(pertext));
    list[1] = new sphere(vec3(0, 2, 0), 1, new lambertian(pertext));
    return new hittable_list(list, 2);
}
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>vec3 lookfrom(13,4,3);
vec3 lookat(0,2,0);
float dist_to_focus = 10.0;
float aperture = 0.0;
float vfov = 20.0;

camera cam(lookfrom, lookat, vec3(0,1,0), vfov, float(nx)/float(ny),aperture, dist_to_focus, 0.0, 1.0);
hittable* world=two_perlin_spheres();
</code></pre><p>&#x6E32;&#x67D3;&#x51FA;&#x7684;&#x56FE;&#x7247;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e3036a92fb38b8c3ccb988b.png" alt></p>
<hr>
<h3 class="mume-header" id="turb">turb</h3>

<pre data-role="codeBlock" data-info class="language-"><code>float turb(const vec3 &amp;p, int depth = 7) const {
    float accum = 0;
    vec3 temp_p = p;
    float weight = 1.0;

    for (int i = 0; i &lt; depth; i++) {
      accum += weight * noise(temp_p);
      weight *= 0.5;
      temp_p *= 2;
    }
    return fabs(accum);
}
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>class noise_texture : public texture {
    public:
        noise_texture() {}
        noise_texture(float sc) : scale(sc) {}
        virtual vec3 value(float u, float v, const vec3&amp; p) const {
            return vec3(1,1,1) * 0.5 * (1 + sin(scale*p.z() + 10*noise.turb(p)));
        }
        perlin noise;
        float scale;
};
</code></pre><p>&#x52A0;&#x4E0A;turbulence&#x540E;&#x6E32;&#x67D3;&#x51FA;&#x7684;&#x5927;&#x7406;&#x77F3;&#x6750;&#x8D28;</p>
<p><img src="https://pic.downk.cc/item/5e303a112fb38b8c3ccbe11a.png" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary XIII - Image Texture Mapping<br>
date: 2020-01-26</p>
<hr>
<h1 class="mume-header" id="%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84">&#x7EB9;&#x7406;&#x6620;&#x5C04;</h1>

<p>&#x7EB9;&#x7406;&#x6620;&#x5C04;&#xFF0C;&#x5C31;&#x662F;&#x901A;&#x8FC7;&#x8BFB;&#x53D6;&#x4E00;&#x5F20;&#x56FE;&#x7247;&#xFF0C;&#x4F7F;&#x7528;uv&#x6620;&#x5C04;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x76F4;&#x63A5;&#x5C06;&#x4E00;&#x5F20;&#x56FE;&#x7247;&#x7684;&#x7EB9;&#x7406;&#x7ED8;&#x5236;&#x5728;&#x7269;&#x4F53;&#x8868;&#x9762;&#x3002;</p>
<p>&#x76F4;&#x63A5;&#x7684;&#x65B9;&#x6CD5;&#x662F;&#x7F29;&#x653E;uv&#xFF0C;uv&#x662F;[0,1]&#x4E4B;&#x95F4;&#x7684;float&#x3002;&#x800C;&#x50CF;&#x7D20;&#x80AF;&#x5B9A;&#x5927;&#x4E8E;&#x8FD9;&#x4E2A;&#x533A;&#x95F4;&#xFF0C;&#x6240;&#x4EE5;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x7F29;&#x653E;&#xFF0C;&#x7528;(i,j)&#x8868;&#x793A;&#x5F53;&#x524D;&#x50CF;&#x7D20;&#xFF0C;nx&#x548C;ny&#x8868;&#x793A;&#x7EB9;&#x7406;&#x7684;&#x5206;&#x8FA8;&#x7387;&#xFF0C;&#x6240;&#x4EE5;&#x5BF9;&#x4E8E;&#x4EFB;&#x610F;&#x50CF;&#x7D20;(i,j)&#x4F4D;&#x7F6E;&#xFF0C;&#x5BF9;&#x5E94;&#x7684;uv&#x5750;&#x6807;&#x5C31;&#x662F;</p>
<p><strong>u = i / (nx - 1)</strong></p>
<p><strong>v = j / (ny - 1)</strong></p>
<hr>
<h3 class="mume-header" id="%E8%AF%BB%E5%8F%96%E7%BA%B9%E7%90%86">&#x8BFB;&#x53D6;&#x7EB9;&#x7406;</h3>

<p><a href="https://github.com/nothings/stb/blob/master/stb_image.h"></a></p>
<p>&#x6211;&#x4EEC;&#x7528;stb_image&#x8FD9;&#x4E2A;&#x5E93;&#x6765;&#x8BFB;&#x53D6;&#x56FE;&#x7247;&#x7EB9;&#x7406;&#xFF0C;&#x5728;&#x4F7F;&#x7528;&#x524D;&#xFF0C;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x521D;&#x59CB;&#x5316;</p>
<pre data-role="codeBlock" data-info class="language-"><code># define STB_IMAGE_IMPLEMENTATION
&lt;p class=&quot;mume-header &quot; id=&quot;define-stb_image_implementation&quot;&gt;&lt;/p&gt;

# include &quot;stb_image.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-stb_imageh&quot;&gt;&lt;/p&gt;

</code></pre><p>&#x53EF;&#x4EE5;&#x7528;stbi_load&#x51FD;&#x6570;&#x5C06;&#x7EB9;&#x7406;&#x6570;&#x636E;&#x5B58;&#x5165;data&#x4E2D;</p>
<pre data-role="codeBlock" data-info class="language-"><code>// Basic usage
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &amp;x, &amp;y, &amp;n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace &apos;0&apos; with &apos;1&apos;..&apos;4&apos; to force that many components per pixel
//    // ... but &apos;n&apos; will always be the number that it would have been if you said 0
</code></pre><p>x&#xFF0C;y&#x662F;&#x56FE;&#x7247;&#x7684;&#x5BBD;&#xFF0C;&#x9AD8;</p>
<hr>
<h3 class="mume-header" id="%E6%8A%95%E5%BD%B1%E5%87%BD%E6%95%B0">&#x6295;&#x5F71;&#x51FD;&#x6570;</h3>

<p>&#x4F7F;&#x7528;&#x7403;&#x7684;&#x9876;&#x70B9;&#x6765;&#x6C42;&#x7403;&#x9762;&#x7684;&#x7EB9;&#x7406;&#x5750;&#x6807;&#xFF0C;&#x793A;&#x610F;&#x56FE;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e3111562fb38b8c3cde3bf4.jpg" alt></p>
<p>&#x5BF9;&#x4EA4;&#x70B9;P(x,y,z)&#x548C;&#x534A;&#x5F84;r&#xFF0C;&#x6620;&#x5C04;&#x6210;&#x7403;&#x5750;&#x6807;&#x7684;&#x3B8;&#x548C;&#x3D5;&#x3002;&#x6709;&#x4EE5;&#x4E0B;&#x516C;&#x5F0F;</p>
<p><strong>x=r*cos&#x3B8;cos&#x3D5;</strong></p>
<p><strong>y=r*sin&#x3B8;</strong></p>
<p><strong>z=r*cos&#x3B8;sin&#x3D5;</strong></p>
<p>&#x8BBE; <strong>r=1</strong>&#xFF0C;&#x5219;</p>
<pre data-role="codeBlock" data-info class="language-"><code>float theta = asin(p.y());
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>float phi = atan2(p.z(), p.x());
</code></pre><p>&#x63A5;&#x4E0B;&#x6765;&#x6211;&#x4EEC;&#x8981;&#x5C06;&#x3D5;&#xFF0C;&#x3B8;&#x6620;&#x5C04;&#x5230;(0,1)&#x5185;</p>
<p>&#x7EB9;&#x7406;&#x5750;&#x6807;&#x7684;u&#x5BF9;&#x5E94;&#x3D5;&#xFF0C;&#x3D5;&#x7684;&#x8303;&#x56F4;&#x662F;&#x4ECE;[-&#x3C0;,&#x3C0;]&#xFF0C;&#x6620;&#x5C04;&#x5230;[0,1]&#x4E4B;&#x95F4;&#xFF0C;&#x5373;&#xFF1A;</p>
<pre data-role="codeBlock" data-info class="language-"><code>u = float(1 - (phi + M_PI) / (2 * M_PI));
</code></pre><p>&#x4E0A;&#x9762;&#x9664;&#x4E86;&#x4E2A;1&#x662F;&#x98A0;&#x5012;&#x4E00;&#x4E0B;&#xFF0C;&#x4EE5;&#x8BA9;&#x7403;&#x9762;&#x56FE;&#x7247;&#x5411;&#x4E0A;&#x3002;</p>
<p>v&#x503C;&#x5BF9;&#x5E94;&#x3B8;&#xFF0C;&#x3B8;&#x7684;&#x8303;&#x56F4;&#x662F;&#x4ECE;[-&#x3C0;/2,&#x3C0;/2],&#x6620;&#x5C04;&#x5230;[0,1]&#x4E4B;&#x95F4;&#xFF0C;&#x5373;&#xFF1A;</p>
<pre data-role="codeBlock" data-info class="language-"><code>v = float((theta + M_PI / 2) / M_PI);
</code></pre><p>&#x7531;&#x4E0A;&#x6574;&#x7406;&#x6210;&#x4E00;&#x4E2A;&#x6839;&#x636E;&#x4EA4;&#x70B9;p&#x6C42;uv&#x7684;&#x51FD;&#x6570;&#x4E3A;&#xFF1A;</p>
<pre data-role="codeBlock" data-info class="language-"><code>void get_sphere_uv(const vec3&amp; p, float&amp; u, float&amp; v)
{
    float phi = atan2(p.z(), p.x());
    float theta = asin(p.y());
    u = float(1 - (phi + M_PI) / (2 * M_PI));
    v = float((theta + M_PI / 2) / M_PI);
}
</code></pre><p><strong>&#x5BF9;&#x4E8E;&#x7B80;&#x5355;&#x7684;&#x51E0;&#x4F55;&#x5F62;&#x72B6;&#xFF0C;&#x5982;&#x7403;&#x5F62;&#x3001;&#x5706;&#x67F1;&#x6295;&#x5F71;&#x51FD;&#x6570;&#x662F;&#x53EF;&#x4EE5;&#x7528;&#x6570;&#x5B66;&#x63A8;&#x5BFC;&#x7684;&#xFF0C;&#x5728;&#x5E38;&#x89C4;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x6295;&#x5F71;&#x51FD;&#x6570;&#x901A;&#x5E38;&#x5728;&#x7F8E;&#x672F;&#x5EFA;&#x6A21;&#x9636;&#x6BB5;&#x4F7F;&#x7528;&#xFF0C;&#x5E76;&#x5C06;&#x6295;&#x5F71;&#x7ED3;&#x679C;&#x5B58;&#x50A8;&#x4E8E;&#x9876;&#x70B9;&#x6570;&#x636E;&#x4E2D;&#x3002;&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#xFF0C;&#x5728;&#x8F6F;&#x4EF6;&#x5F00;&#x53D1;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x4E00;&#x822C;&#x4E0D;&#x4F1A;&#x53BB;&#x7528;&#x6295;&#x5F71;&#x51FD;&#x6570;&#x53BB;&#x8BA1;&#x7B97;&#x5F97;&#x5230;&#x6295;&#x5F71;&#x7ED3;&#x679C;&#xFF0C;&#x800C;&#x662F;&#x76F4;&#x63A5;&#x4F7F;&#x7528;&#x5728;&#x7F8E;&#x672F;&#x5EFA;&#x6A21;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x5DF2;&#x7ECF;&#x5B58;&#x50A8;&#x5728;&#x6A21;&#x578B;&#x9876;&#x70B9;&#x6570;&#x636E;&#x4E2D;&#x7684;&#x6295;&#x5F71;&#x7ED3;&#x679C; &#x2014; Real-Time Rendering 3rd</strong></p>
<hr>
<h3 class="mume-header" id="%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86%E7%B1%BB">&#x56FE;&#x7247;&#x7EB9;&#x7406;&#x7C7B;</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef IMAGETEXTURE
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-imagetexture&quot;&gt;&lt;/p&gt;

# define IMAGETEXTURE
&lt;p class=&quot;mume-header &quot; id=&quot;define-imagetexture&quot;&gt;&lt;/p&gt;


# define STB_IMAGE_IMPLEMENTATION
&lt;p class=&quot;mume-header &quot; id=&quot;define-stb_image_implementation-1&quot;&gt;&lt;/p&gt;

# include &quot;stb_image.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-stb_imageh-1&quot;&gt;&lt;/p&gt;

# include &quot;texture.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-textureh&quot;&gt;&lt;/p&gt;


class image_texture : public texture {
    public:
        image_texture() {}
        image_texture(unsigned char *pixels, int A, int B)
            : data(pixels), nx(A), ny(B) {}
        virtual vec3 value(float u, float v, const vec3&amp; p) const;
        unsigned char *data; //&#x7EB9;&#x7406;&#x6570;&#x636E;
        int nx, ny; //&#x7EB9;&#x7406;&#x7684;&#x957F;&#xFF0C;&#x5BBD;
};

//&#x63D0;&#x53D6;data&#x6570;&#x636E;&#x4E2D;&#x6307;&#x5B9A;&#x4F4D;&#x7F6E;&#x7684;rgb&#x503C;
vec3 image_texture::value(float u, float v, const vec3&amp; p) const {
     int i = (u) * nx;
     int j = (1-v) * ny - 0.001;
     if (i &lt; 0) i = 0;
     if (j &lt; 0) j = 0;
     if (i &gt; nx-1) i = nx-1;
     if (j &gt; ny-1) j = ny-1;
     float r = int(data[3*i + 3*nx*j]  ) / 255.0;
     float g = int(data[3*i + 3*nx*j+1]) / 255.0;
     float b = int(data[3*i + 3*nx*j+2]) / 255.0;
     return vec3(r, g, b);
}
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-11&quot;&gt;&lt;/p&gt;

</code></pre><hr>
<p>&#x4FEE;&#x6539;hittable.h</p>
<pre data-role="codeBlock" data-info class="language-"><code>void get_sphere_uv(const vec3&amp; p, float&amp; u, float&amp; v) {
    float phi = atan2(p.z(), p.x());
    float theta = asin(p.y());
    u = 1-(phi + M_PI) / (2*M_PI);
    v = (theta + M_PI/2) / M_PI;
}

struct hit_record {
    float t;  
    float u;
    float v;
    vec3 p;
    vec3 normal; 
    material *mat_ptr;
};
</code></pre><p>sphere.h</p>
<p>get_sphere_uv&#x83B7;&#x53D6;&#x649E;&#x51FB;&#x70B9;&#x7684;&#x5750;&#x6807;</p>
<pre data-role="codeBlock" data-info class="language-"><code>bool sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    float a = dot(r.direction(), r.direction());
    float b = dot(oc, r.direction());
    float c = dot(oc, oc) - radius*radius;
    float discriminant = b*b - a*c;
    if (discriminant &gt; 0) {
        
        float temp = (-b - sqrt(discriminant))/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            get_sphere_uv((rec.p-center)/radius, rec.u, rec.v);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; 
            return true;
        }
        
         temp = (-b + sqrt(discriminant)) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            get_sphere_uv((rec.p-center)/radius, rec.u, rec.v);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; 
            return true;
        }
    }
    return false;
}
</code></pre><p>material.h</p>
<p>&#x53CD;&#x5C04;&#x6C42;&#x53D6;&#x56FE;&#x7247;&#x5BF9;&#x5E94;&#x51FA;&#x7684;&#x50CF;&#x7D20;&#x503C;</p>
<pre data-role="codeBlock" data-info class="language-"><code>class lambertian : public material {
    public:
        lambertian(texture *a) : albedo(a) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const  {
             vec3 target = rec.p + rec.normal + random_in_unit_sphere();
             scattered = ray(rec.p, target-rec.p, r_in.time());
             attenuation = albedo-&gt;value(rec.u, rec.v, rec.p);
             return true;
        }
        texture *albedo;
};
</code></pre><p>main.cpp</p>
<p>&#x8BFB;&#x53D6;&#x5E76;&#x751F;&#x6210;&#x7EB9;&#x7406;</p>
<pre data-role="codeBlock" data-info class="language-"><code>hittable* texture_spheres(){
    int nx, ny, nn;
    unsigned char *tex_data = stbi_load(&quot;earthmap.jpg&quot;, &amp;nx, &amp;ny, &amp;nn, 0);
    material *mat = new lambertian(new image_texture(tex_data, nx, ny));
    int n = 50;
    hittable **list = new hittable*[n+1];
    list[0] = new sphere(vec3(0,0, 0), 1, mat);
    return new hittable_list(list,1);
}
</code></pre><hr>
<p>&#x6700;&#x7EC8;&#x6E32;&#x67D3;&#x7684;&#x56FE;&#x7247;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e2e71af2fb38b8c3ca808d3.png" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary XIV - Rectangles &amp; Lights &amp; Translation<br>
date: 2020-01-27</p>
<hr>
<h1 class="mume-header" id="%E7%9F%A9%E5%BD%A2-%E5%85%89%E7%85%A7-%E5%8F%98%E6%8D%A2">&#x77E9;&#x5F62; &#x5149;&#x7167; &#x53D8;&#x6362;</h1>

<hr>
<p>&#x77E9;&#x5F62;&#x548C;&#x5149;&#x7167;&#x3002;&#x5982;&#x4F55;&#x505A;&#x4E00;&#x4E2A;&#x81EA;&#x53D1;&#x5149;&#x7684;&#x6750;&#x8D28;&#xFF0C;&#x9996;&#x5148;&#x987B;&#x8981;&#x5728;hit_record&#x91CC;&#x9762;&#x52A0;&#x4E00;&#x4E2A; emitted&#x7684;&#x65B9;&#x6CD5;&#x3002;&#x6BD4;&#x5982;&#x8BF4;&#x80CC;&#x666F;&#x5982;&#x679C;&#x662F;&#x7EAF;&#x9ED1;&#x7684;&#x8BDD;&#xFF0C;&#x5C31;&#x76F8;&#x5F53;&#x4E8E;&#x5149;&#x7EBF;&#x6765;&#x4E86;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x4ED6;&#x4E0D;&#x53CD;&#x5C04;&#x4EFB;&#x4F55;&#x5149;&#x7EBF;&#x3002;</p>
<h3 class="mume-header" id="%E8%87%AA%E5%8F%91%E5%85%89">&#x81EA;&#x53D1;&#x5149;</h3>

<p>&#x5728;material&#x7C7B;&#x4E2D;&#x6DFB;&#x52A0;&#x865A;&#x51FD;&#x6570;emitted&#xFF0C;&#x9ED8;&#x8BA4;&#x8FD4;&#x56DE;&#x9ED1;&#x8272;</p>
<pre data-role="codeBlock" data-info class="language-"><code>virtual vec3 emitted(float u, float v, const vec3&amp; p) const {
    return vec3(0,0,0);
}
</code></pre><p>diffuse_light&#x7C7B;</p>
<pre data-role="codeBlock" data-info class="language-"><code>class diffuse_light : public material {
    public:
        diffuse_light(texture *a) : emit(a) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec,
            vec3&amp; attenuation, ray&amp; scattered) const { return false; }
        virtual vec3 emitted(float u, float v, const vec3&amp; p) const {
            return emit-&gt;value(u, v, p);
        }
        texture *emit;
};
</code></pre><p>color&#x51FD;&#x6570;</p>
<pre data-role="codeBlock" data-info class="language-"><code>vec3 color(const ray&amp; r, hittable *world, int depth) {
    hit_record rec;
    if (world-&gt;hit(r, 0.001, MAXFLOAT, rec)) {
        ray scattered;
        vec3 attenuation;
        vec3 emitted = rec.mat_ptr-&gt;emitted(rec.u, rec.v, rec.p);
        if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered))
             return emitted + attenuation*color(scattered, world, depth+1);
        else
            return emitted;
    }
    else
        return vec3(0,0,0);
}
</code></pre><h3 class="mume-header" id="%E7%9F%A9%E5%BD%A2">&#x77E9;&#x5F62;</h3>

<p>&#x4EE5;xy&#x5E73;&#x9762;&#x4E0A;&#x7684;&#x77E9;&#x5F62;&#x4E3A;&#x4F8B;&#xFF0C;&#x5728; <strong>z=k</strong>&#x65F6;&#xFF0C;<strong>x0</strong>&#xFF0C;<strong>x1</strong>&#xFF0C;<strong>y0</strong>&#xFF0C;<strong>y1</strong>&#x53EF;&#x4EE5;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A;&#x77E9;&#x5F62;&#x5E73;&#x9762;&#x533A;&#x57DF;</p>
<p><img src="https://raytracing.github.io/images/fig-2-7-01.jpg" alt></p>
<p>&#x8BA1;&#x7B97;&#x5149;&#x7EBF;&#x548C;&#x77E9;&#x5F62;&#x76F8;&#x4EA4;&#x7684;&#x65B9;&#x7A0B;&#x5982;&#x4E0B;</p>
<p><strong>p(t)=a+t*b</strong></p>
<p><strong>z(t)=az+t*bz</strong></p>
<p><strong>z=k</strong></p>
<p>&#x89E3;&#x5F97;&#xFF1A;</p>
<p><strong>t=(k&#x2212;az)/bz</strong></p>
<p><strong>x=ax+t&#x2217;bx</strong></p>
<p><strong>y=ay+t&#x2217;by</strong></p>
<p>&#x5982;&#x679C;&#x540C;&#x65F6;x&#x5728;&#x533A;&#x95F4;[x0,x1]&#xFF0C;y&#x5728;[y0,y1]&#x4E0A;&#xFF0C;&#x5149;&#x7EBF;&#x5C31;&#x548C;&#x77E9;&#x5F62;&#x76F8;&#x4EA4;</p>
<h3 class="mume-header" id="xyz_rech">xyz_rec.h</h3>

<pre data-role="codeBlock" data-info class="language-"><code># ifndef XYZRECT
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-xyzrect&quot;&gt;&lt;/p&gt;

# define XYZRECT 
&lt;p class=&quot;mume-header &quot; id=&quot;define-xyzrect&quot;&gt;&lt;/p&gt;


# include &quot;hittable.h&quot;
&lt;p class=&quot;mume-header &quot; id=&quot;include-hittableh-4&quot;&gt;&lt;/p&gt;


class xy_rect:public hittable
{
    public:
        xy_rect();
        xy_rect(float _x0, float _x1, float _y0, float _y1, float _k, material *mat)
                : x0(_x0), x1(_x1), y0(_y0), y1(_y1), k(_k), mp(mat) {};
        ~xy_rect();
        virtual bool hit(const ray&amp; r,float t_min,float t_max,hit_record&amp; rec)const;
        virtual bool bounding_box(float t_min,float t_max,aabb&amp; box)const;

        float x0,x1,y0,y1,k;
        material *mp;
};

class xz_rect: public hittable {
    public:
        xz_rect() {}
        xz_rect(float _x0, float _x1, float _z0, float _z1, float _k, material *mat)
            : x0(_x0), x1(_x1), z0(_z0), z1(_z1), k(_k), mp(mat) {};
        virtual bool hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const;
        virtual bool bounding_box(float t_min, float t_max, aabb&amp; box) const;
        
        material *mp;
        float x0, x1, z0, z1, k;
};

class yz_rect: public hittable {
    public:
        yz_rect() {}
        yz_rect(float _y0, float _y1, float _z0, float _z1, float _k, material *mat)
            : y0(_y0), y1(_y1), z0(_z0), z1(_z1), k(_k), mp(mat) {};
        virtual bool hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const;
        virtual bool bounding_box(float t_min, float t_max, aabb&amp; box) const;

        material  *mp;
        float y0, y1, z0, z1, k;
};
bool xy_rect::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    float t = (k-r.origin().z()) / r.direction().z();
    if (t &lt; t_min || t &gt; t_max)
        return false;
    float x = r.origin().x() + t*r.direction().x();
    float y = r.origin().y() + t*r.direction().y();
    if (x &lt; x0 || x &gt; x1 || y &lt; y0 || y &gt; y1)
        return false;
    rec.u = (x-x0)/(x1-x0);
    rec.v = (y-y0)/(y1-y0);
    rec.t = t;
    rec.mat_ptr = mp;
    rec.p = r.point_at_parameter(t);
    rec.normal = vec3(0, 0, 1);
    return true;
}
bool xy_rect::bounding_box(float t_min,float t_max,aabb&amp; box)const{
    box =  aabb(vec3(x0,y0, k-0.0001), vec3(x1, y1, k+0.0001));
    return true;
}

bool xz_rect::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    float t = (k-r.origin().y()) / r.direction().y();
    if (t &lt; t_min || t &gt; t_max)
        return false;
    float x = r.origin().x() + t*r.direction().x();
    float z = r.origin().z() + t*r.direction().z();
    if (x &lt; x0 || x &gt; x1 || z &lt; z0 || z &gt; z1)
        return false;
    rec.u = (x-x0)/(x1-x0);
    rec.v = (z-z0)/(z1-z0);
    rec.t = t;
    rec.mat_ptr = mp;
    rec.p = r.point_at_parameter(t);
    rec.normal = vec3(0, 1, 0);
    return true;
}

bool xz_rect::bounding_box(float t_min, float t_max, aabb&amp; box) const {
    box =  aabb(vec3(x0,k-0.0001,z0), vec3(x1, k+0.0001, z1));
    return true;
}

bool yz_rect::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    float t = (k-r.origin().x()) / r.direction().x();
    if (t &lt; t_min || t &gt; t_max)
        return false;
    float y = r.origin().y() + t*r.direction().y();
    float z = r.origin().z() + t*r.direction().z();
    if (y &lt; y0 || y &gt; y1 || z &lt; z0 || z &gt; z1)
        return false;
    rec.u = (y-y0)/(y1-y0);
    rec.v = (z-z0)/(z1-z0);
    rec.t = t;
    rec.mat_ptr = mp;
    rec.p = r.point_at_parameter(t);
    rec.normal = vec3(1, 0, 0);
    return true;
}

bool yz_rect::bounding_box(float t_min, float t_max, aabb&amp; box) const {
    box =  aabb(vec3(k-0.0001, y0, z0), vec3(k+0.0001, y1, z1));
    return true;
}
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-12&quot;&gt;&lt;/p&gt;

</code></pre><p>&#x7C7B;&#x4E2D;&#x6709;hit&#x548C;bounding_box&#x4E24;&#x4E2A;&#x6210;&#x5458;&#x51FD;&#x6570;</p>
<h3 class="mume-header" id="flip_normalsh">flip_normals.h</h3>

<p>&#x5728;&#x524D;&#x4E00;&#x6B65;&#x505A;&#x5B8C;&#x540E;&#xFF0C;&#x6E32;&#x67D3;&#x51FA;&#x7684;cornell box&#x6709;&#x4E00;&#x4E2A;bug&#xFF0C;&#x6211;&#x4EEC;&#x6240;&#x5EFA;&#x7ACB;&#x7684;&#x77E9;&#x5F62;&#x662F;&#x6709;&#x671D;&#x5411;&#x7684;&#xFF0C;&#x5149;&#x7167;&#x5C04;&#x5230;&#x77E9;&#x5F62;&#x80CC;&#x9762;&#x65F6;&#x53EA;&#x4F1A;&#x6E32;&#x67D3;&#x51FA;&#x9ED1;&#x8272;&#xFF0C;&#x56E0;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x8981;&#x5BF9;&#x4E00;&#x4E9B;&#x77E9;&#x5F62;&#x8FDB;&#x884C;&#x6CD5;&#x5411;&#x91CF;&#x7684;&#x7FFB;&#x8F6C;</p>
<p>flip_normals.h</p>
<pre data-role="codeBlock" data-info class="language-"><code>class flip_normals : public hittable {
    public:
        flip_normals(hittable *p) : ptr(p) {}

        virtual bool hit(
            const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {

            if (ptr-&gt;hit(r, t_min, t_max, rec)) {
                rec.normal = -rec.normal;
                return true;
            }
            else
                return false;
        }

        virtual bool bounding_box(float t0, float t1, aabb&amp; box) const {
            return ptr-&gt;bounding_box(t0, t1, box);
        }

        hittable *ptr;
};
</code></pre><h3 class="mume-header" id="test-1">test</h3>

<p>&#x63A5;&#x4E0B;&#x6765;&#x6E32;&#x67D3;&#x4E00;&#x4E2A;cornell_box</p>
<pre data-role="codeBlock" data-info class="language-"><code>hittable *cornell_box() {
    hittable **list = new hittable*[50];
    int i = 0;
    material *red = new lambertian(new constant_texture(vec3(0.65, 0.05, 0.05)));
    material *white = new lambertian(new constant_texture(vec3(0.73, 0.73, 0.73)));
    material *green = new lambertian(new constant_texture(vec3(0.12, 0.45, 0.15)));
    material *light = new diffuse_light(new constant_texture(vec3(15, 15, 15)));
    material *spec = new metal(vec3(1,1,1),0);

    list[i++] = new flip_normals(new yz_rect(0, 555, 0, 555, 555, green));
    list[i++] = new yz_rect(0, 555, 0, 555, 0, red);
    list[i++] = new xz_rect(213, 343, 227, 332, 554, light);
    list[i++] = new flip_normals(new xz_rect(0, 555, 0, 555, 555, white));
    list[i++] = new xz_rect(0, 555, 0, 555, 0, white);
    list[i++] = new flip_normals(new xy_rect(0, 555, 0, 555, 555, white));

    list[i++] = new sphere(vec3(150, 150, 350), 100, spec);
    list[i++] = new sphere(vec3(350, 100, 500), 100, green);

    return new hittable_list(list,i);
}
</code></pre><pre data-role="codeBlock" data-info class="language-"><code>vec3 lookfrom(278, 278, -800);
vec3 lookat(278,278,0);
float dist_to_focus = 10.0;
float aperture = 0.0;
float vfov = 40.0;
camera cam(lookfrom, lookat, vec3(0,1,0), vfov, float(nx)/float(ny),aperture, dist_to_focus, 0.0, 1.0);
</code></pre><p>&#x6E32;&#x67D3;&#x7ED3;&#x679C;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e31999e2fb38b8c3ce9b208.png" alt></p>
<h3 class="mume-header" id="%E9%95%BF%E6%96%B9%E4%BD%93">&#x957F;&#x65B9;&#x4F53;</h3>

<p>&#x957F;&#x65B9;&#x4F53;&#x7C7B;&#x7684;&#x5B9A;&#x4E49;&#x53EA;&#x9700;&#x8981;&#x5B9A;&#x4E49;8&#x4E2A;&#x76F8;&#x90BB;&#x7684;&#x77E9;&#x5F62;&#x5373;&#x53EF;</p>
<pre data-role="codeBlock" data-info class="language-"><code>class box: public hittable {
    public:
        box() {}
        box(const vec3&amp; p0, const vec3&amp; p1, material *ptr);
        virtual bool hit(const ray&amp; r, float t0, float t1, hit_record&amp; rec) const;
        virtual bool bounding_box(float t0, float t1, aabb&amp; box) const {
            box =  aabb(pmin, pmax);
            return true;
        }
        vec3 pmin, pmax;
        hittable *list_ptr;
};

box::box(const vec3&amp; p0, const vec3&amp; p1, material *ptr) {
    pmin = p0;
    pmax = p1;
    hittable **list = new hittable*[6];
    list[0] = new xy_rect(p0.x(), p1.x(), p0.y(), p1.y(), p1.z(), ptr);
    list[1] = new flip_normals(
        new xy_rect(p0.x(), p1.x(), p0.y(), p1.y(), p0.z(), ptr));
    list[2] = new xz_rect(p0.x(), p1.x(), p0.z(), p1.z(), p1.y(), ptr);
    list[3] = new flip_normals(
        new xz_rect(p0.x(), p1.x(), p0.z(), p1.z(), p0.y(), ptr));
    list[4] = new yz_rect(p0.y(), p1.y(), p0.z(), p1.z(), p1.x(), ptr);
    list[5] = new flip_normals(
        new yz_rect(p0.y(), p1.y(), p0.z(), p1.z(), p0.x(), ptr));
    list_ptr = new hittable_list(list,6);
}

bool box::hit(const ray&amp; r, float t0, float t1, hit_record&amp; rec) const {
    return list_ptr-&gt;hit(r, t0, t1, rec);
}
</code></pre><h3 class="mume-header" id="%E5%8F%98%E6%8D%A2">&#x53D8;&#x6362;</h3>

<h4 class="mume-header" id="%E5%B9%B3%E7%A7%BB">&#x5E73;&#x79FB;</h4>

<p>translate.h</p>
<pre data-role="codeBlock" data-info class="language-"><code># ifndef TRANSLATE
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-translate&quot;&gt;&lt;/p&gt;

# define TRANSLATE 
&lt;p class=&quot;mume-header &quot; id=&quot;define-translate&quot;&gt;&lt;/p&gt;


class translate : public hittable {
    public:
        translate(hittable *p, const vec3&amp; displacement) : ptr(p), offset(displacement) {}
        virtual bool hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const;
        virtual bool bounding_box(float t0, float t1, aabb&amp; box) const;
        hittable *ptr;
        vec3 offset;
};

bool translate::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    ray moved_r(r.origin() - offset, r.direction(), r.time());//&#x5E73;&#x79FB;&#x5149;&#x7EBF;
    if (ptr-&gt;hit(moved_r, t_min, t_max, rec)) {
        //&#x5E73;&#x79FB;&#x4EA4;&#x70B9;
        rec.p += offset;
        return true;
    }
    else
        return false;
}

bool translate::bounding_box(float t0, float t1, aabb&amp; box) const {
    if (ptr-&gt;bounding_box(t0, t1, box)) {
        box = aabb(box.min() + offset, box.max() + offset);
        return true;
    }
    else
        return false;
}
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-13&quot;&gt;&lt;/p&gt;

</code></pre><h4 class="mume-header" id="%E6%97%8B%E8%BD%AC">&#x65CB;&#x8F6C;</h4>

<p>&#x7269;&#x4F53;&#x7ED5;z&#x8F74;&#x65CB;&#x8F6C;&#x7684;&#x793A;&#x610F;&#x56FE;&#x5982;&#x4E0B;</p>
<p><img src="https://pic1.zhimg.com/80/v2-72fae3a355859660cdf42881b335d30c_hd.jpg" alt></p>
<p>&#x65CB;&#x8F6C;&#x89D2;&#x5EA6;&#x4E3A;&#x3B8;</p>
<pre data-role="codeBlock" data-info class="language-"><code>x&apos;=cos(&#x3B8;)*x-sin(&#x3B8;)*y
y&apos;=sin(&#x3B8;)*x+cos(&#x3B8;)*y
</code></pre><p>rotate.h</p>
<pre data-role="codeBlock" data-info class="language-"><code># ifndef ROTATE
&lt;p class=&quot;mume-header &quot; id=&quot;ifndef-rotate&quot;&gt;&lt;/p&gt;

# define ROTATE 
&lt;p class=&quot;mume-header &quot; id=&quot;define-rotate&quot;&gt;&lt;/p&gt;


class rotate_y : public hittable {
    public:
        rotate_y(hittable *p, float angle);
        virtual bool hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const;
        virtual bool bounding_box(float t0, float t1, aabb&amp; box) const {
            box = bbox; return hasbox;
        }
        hittable *ptr;
        float sin_theta;
        float cos_theta;
        bool hasbox;
        aabb bbox;
};

rotate_y::rotate_y(hittable *p, float angle) : ptr(p) {
    float radians = (M_PI / 180.) * angle;
    sin_theta = sin(radians);
    cos_theta = cos(radians);
    hasbox = ptr-&gt;bounding_box(0, 1, bbox);
    vec3 min(FLT_MAX, FLT_MAX, FLT_MAX);
    vec3 max(-FLT_MAX, -FLT_MAX, -FLT_MAX);
    for (int i = 0; i &lt; 2; i++) {
        for (int j = 0; j &lt; 2; j++) {
            for (int k = 0; k &lt; 2; k++) {
                float x = i*bbox.max().x() + (1-i)*bbox.min().x();
                float y = j*bbox.max().y() + (1-j)*bbox.min().y();
                float z = k*bbox.max().z() + (1-k)*bbox.min().z();
                float newx = cos_theta*x + sin_theta*z;
                float newz = -sin_theta*x + cos_theta*z;
                vec3 tester(newx, y, newz);
                //&#x91CD;&#x65B0;&#x8BA1;&#x7B97;bounding_box
                for ( int c = 0; c &lt; 3; c++ )
                {
                    if ( tester[c] &gt; max[c] )
                        max[c] = tester[c];
                    if ( tester[c] &lt; min[c] )
                        min[c] = tester[c];
                }
            }
        }
    }
    bbox = aabb(min, max);
}

//&#x4EA4;&#x70B9;&#xFF0C;&#x6CD5;&#x7EBF;&#xFF0C;&#x5165;&#x5C04;&#x5149;&#x7EBF;&#x4E5F;&#x505A;&#x540C;&#x6837;&#x7684;&#x65CB;&#x8F6C;
bool rotate_y::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    vec3 origin = r.origin();
    vec3 direction = r.direction();
    origin[0] = cos_theta*r.origin()[0] - sin_theta*r.origin()[2];
    origin[2] =  sin_theta*r.origin()[0] + cos_theta*r.origin()[2];
    direction[0] = cos_theta*r.direction()[0] - sin_theta*r.direction()[2];
    direction[2] = sin_theta*r.direction()[0] + cos_theta*r.direction()[2];
    ray rotated_r(origin, direction, r.time());
    if (ptr-&gt;hit(rotated_r, t_min, t_max, rec)) {
        vec3 p = rec.p;
        vec3 normal = rec.normal;
        p[0] = cos_theta*rec.p[0] + sin_theta*rec.p[2];
        p[2] = -sin_theta*rec.p[0] + cos_theta*rec.p[2];
        normal[0] = cos_theta*rec.normal[0] + sin_theta*rec.normal[2];
        normal[2] = -sin_theta*rec.normal[0] + cos_theta*rec.normal[2];
        rec.p = p;
        rec.normal = normal;
        return true;
    }
    else
        return false;
}
# endif
&lt;p class=&quot;mume-header &quot; id=&quot;endif-14&quot;&gt;&lt;/p&gt;

</code></pre><hr>
<h3 class="mume-header" id="test-2">test</h3>

<pre data-role="codeBlock" data-info class="language-"><code>hittable *cornell_box() {
    hittable **list = new hittable*[50];
    int i = 0;
    material *red = new lambertian(new constant_texture(vec3(0.65, 0.05, 0.05)));
    material *white = new lambertian(new constant_texture(vec3(0.73, 0.73, 0.73)));
    material *green = new lambertian(new constant_texture(vec3(0.12, 0.45, 0.15)));
    material *light = new diffuse_light(new constant_texture(vec3(15, 15, 15)));
    material *spec = new metal(vec3(1,1,1),0);

    list[i++] = new flip_normals(new yz_rect(0, 555, 0, 555, 555, green));
    list[i++] = new yz_rect(0, 555, 0, 555, 0, red);
    list[i++] = new xz_rect(213, 343, 227, 332, 554, light);
    list[i++] = new flip_normals(new xz_rect(0, 555, 0, 555, 555, white));
    list[i++] = new xz_rect(0, 555, 0, 555, 0, white);
    list[i++] = new flip_normals(new xy_rect(0, 555, 0, 555, 555, white));

    list[i++] = new translate(new rotate_y(new box(vec3(0,0,0), vec3(165,165,165), white), -18),vec3(130,0,65));
    list[i++] = new translate(new rotate_y(new box(vec3(0,0,0), vec3(165,330,165), white), 15),vec3(265,0,295));

    return new hittable_list(list,i);
}
</code></pre><p>&#x6E32;&#x67D3;&#x51FA;&#x7684;&#x56FE;&#x50CF;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e31ad492fb38b8c3ceb61cf.png" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary XV - Volumes<br>
date: 2020-01-29</p>
<hr>
<h1 class="mume-header" id="%E7%83%9F%E9%9B%BE">&#x70DF;&#x96FE;</h1>

<p>&#x5149;&#x7167;&#x5C04;&#x5230;volume&#x4E0A;&#x65F6;&#xFF0C;&#x65E2;&#x6709;&#x53EF;&#x80FD;&#x76F4;&#x63A5;&#x7A7F;&#x8FC7;&#xFF0C;&#x53C8;&#x53EF;&#x80FD;&#x53D1;&#x751F;&#x53CD;&#x5C04;&#xFF0C;&#x6298;&#x5C04;&#x3002;&#x5149;&#x7EBF;&#x5728;&#x70DF;&#x96FE;&#x4F53;&#x4E2D;&#x80FD;&#x4F20;&#x64AD;&#x591A;&#x8FDC;&#xFF0C;&#x662F;&#x7531;volume&#x7684;&#x5BC6;&#x5EA6;&#x51B3;&#x5B9A;&#x7684;&#xFF0C;&#x5BC6;&#x5EA6;&#x8D8A;&#x9AD8;&#xFF0C;&#x5149;&#x7EBF;&#x7A7F;&#x900F;&#x6027;&#x8D8A;&#x5DEE;&#xFF0C;&#x5149;&#x7EBF;&#x4F20;&#x64AD;&#x7684;&#x8DDD;&#x79BB;&#x4E5F;&#x8D8A;&#x77ED;&#x3002;</p>
<p>&#x6211;&#x4EEC;&#x5728;volume&#x7684;&#x5185;&#x90E8;&#x6DFB;&#x52A0;&#x4E00;&#x4E9B;&#x968F;&#x673A;&#x65B9;&#x5411;&#x7684;&#x8868;&#x9762;&#x6765;&#x5B9E;&#x73B0;&#x8FD9;&#x79CD;&#x6548;&#x679C;</p>
<p>&#x5F53;&#x5149;&#x7EBF;&#x901A;&#x8FC7;&#x4F53;&#x79EF;&#x65F6;&#xFF0C;&#x5B83;&#x53EF;&#x80FD;&#x5728;&#x4EFB;&#x4F55;&#x70B9;&#x6563;&#x5C04;&#x3002; &#x5149;&#x7EBF;&#x5728;&#x4EFB;&#x4F55;&#x5C0F;&#x8DDD;&#x79BB;dL&#x4E2D;&#x6563;&#x5C04;&#x7684;&#x6982;&#x7387;&#x4E3A;&#xFF1A;</p>
<p>&#x6982;&#x7387; <strong>p=C*dL</strong>&#xFF0C;&#x5176;&#x4E2D;C&#x4E0E;volume&#x5BC6;&#x5EA6;&#x6210;&#x6B63;&#x6BD4;&#x3002;</p>
<hr>
<p>iostropic.h</p>
<pre data-role="codeBlock" data-info class="language-"><code>class isotropic : public material {
    public:
        isotropic(texture *a) : albedo(a) {}
        virtual bool scatter(
            const ray&amp; r_in,
            const hit_record&amp; rec,
            vec3&amp; attenuation,
            ray&amp; scattered) const {

            scattered = ray(rec.p, random_in_unit_sphere());
            attenuation = albedo-&gt;value(rec.u, rec.v, rec.p);
            return true;
        }
        texture *albedo;
};
</code></pre><p>&#x5728;isotropic.h&#x4E2D;&#xFF0C;volume&#x4E2D;&#x7684;&#x6563;&#x5C04;&#x65B9;&#x5411;&#x662F;&#x968F;&#x673A;&#x65B9;&#x5411;&#xFF0C;&#x4E0E;&#x6F2B;&#x53CD;&#x5C04;&#x4E0D;&#x540C;&#x7684;&#x662F;&#xFF0C;&#x6F2B;&#x53CD;&#x5C04;&#x7684;&#x6563;&#x5C04;&#x5149;&#x7EBF;&#x4E0D;&#x53EF;&#x80FD;&#x6307;&#x5230;&#x7269;&#x4F53;&#x5185;&#x90E8;&#xFF0C;&#x5B83;&#x4E00;&#x5B9A;&#x662F;&#x6563;&#x5C04;&#x5230;&#x8868;&#x9762;&#x5916;&#xFF0C;isotropic&#x6750;&#x8D28;&#x7684;&#x6563;&#x5C04;&#x5149;&#x7EBF;&#x53EF;&#x4EE5;&#x6CBF;&#x539F;&#x6765;&#x7684;&#x65B9;&#x5411;&#x4E00;&#x5F80;&#x524D;&#xFF0C;&#x4EE5;&#x6B64;&#x5B9E;&#x73B0;&#x900F;&#x5149;&#x6027;</p>
<hr>
<p>constant_medium.h</p>
<pre data-role="codeBlock" data-info class="language-"><code>class constant_medium : public hittable {
    public:
        constant_medium(hittable *b, float d, texture *a) : boundary(b), density(d) {
            phase_function = new isotropic(a);
        }
        virtual bool hit(
            const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const;
        virtual bool bounding_box(float t0, float t1, aabb&amp; box) const {
            return boundary-&gt;bounding_box(t0, t1, box);
        }
        hittable *boundary;
        float density;
        material *phase_function;
};

bool constant_medium::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec)
const {
    const bool enableDebug = false;//&#x7528;&#x4E8E;debug
    bool debugging = enableDebug &amp;&amp; random_double() &lt; 0.00001;

    hit_record rec1, rec2;

    if (boundary-&gt;hit(r, -FLT_MAX, FLT_MAX, rec1)) {
        if (boundary-&gt;hit(r, rec1.t+0.0001, FLT_MAX, rec2)) {

            if (debugging) std::cerr &lt;&lt; &quot;\nt0 t1 &quot; &lt;&lt; rec1.t &lt;&lt; &quot; &quot; &lt;&lt; rec2.t &lt;&lt; &apos;\n&apos;;

            if (rec1.t &lt; t_min)
                rec1.t = t_min;

            if (rec2.t &gt; t_max)
                rec2.t = t_max;

            if (rec1.t &gt;= rec2.t)
                return false;

            if (rec1.t &lt; 0)
                rec1.t = 0;

            float distance_inside_boundary = (rec2.t - rec1.t)*r.direction().length();
            float hit_distance = -(1/density) * log(random_double());

            if (hit_distance &lt; distance_inside_boundary) {

                rec.t = rec1.t + hit_distance / r.direction().length();
                rec.p = r.point_at_parameter(rec.t);

                if (debugging) {
                    std::cerr &lt;&lt; &quot;hit_distance = &quot; &lt;&lt;  hit_distance &lt;&lt; &apos;\n&apos;
                              &lt;&lt; &quot;rec.t = &quot; &lt;&lt;  rec.t &lt;&lt; &apos;\n&apos;
                              &lt;&lt; &quot;rec.p = &quot; &lt;&lt;  rec.p &lt;&lt; &apos;\n&apos;;
                }

                rec.normal = vec3(1,0,0);  // arbitrary
                rec.mat_ptr = phase_function;
                return true;
            }
        }
    }
    return false;
}
</code></pre><p>hit&#x51FD;&#x6570;&#x91CC;&#x9762;&#x662F;&#x4E00;&#x4E9B;&#x8FB9;&#x754C;&#x5408;&#x6CD5;&#x6027;&#x68C0;&#x6D4B;</p>
<h3 class="mume-header" id="test-3">test</h3>

<pre data-role="codeBlock" data-info class="language-"><code>hittable *cornell_smoke() {
    hittable **list = new hittable*[8];
    int i = 0;
    material *red = new lambertian(new constant_texture(vec3(0.65, 0.05, 0.05)));
    material *white = new lambertian(new constant_texture(vec3(0.73, 0.73, 0.73)));
    material *green = new lambertian(new constant_texture(vec3(0.12, 0.45, 0.15)));
    material *light = new diffuse_light(new constant_texture(vec3(15, 15, 15)));

    list[i++] = new flip_normals(new yz_rect(0, 555, 0, 555, 555, green));
    list[i++] = new yz_rect(0, 555, 0, 555, 0, red);
    list[i++] = new xz_rect(213, 343, 227, 332, 554, light);
    list[i++] = new flip_normals(new xz_rect(0, 555, 0, 555, 555, white));
    list[i++] = new xz_rect(0, 555, 0, 555, 0, white);
    list[i++] = new flip_normals(new xy_rect(0, 555, 0, 555, 555, white));

    hittable *b1 = new translate(new rotate_y(new box(vec3(0, 0, 0), vec3(165, 165, 165), white), -18),vec3(130,0,65));
    hittable *b2 = new translate(new rotate_y(new box(vec3(0, 0, 0), vec3(165, 330, 165), white),  15),vec3(265,0,295));

    list[i++] = new constant_medium(b1, 0.01, new constant_texture(vec3(1.0, 1.0, 1.0)));
    list[i++] = new constant_medium(b2, 0.01, new constant_texture(vec3(0.0, 0.0, 0.0)));
        
    return new hittable_list(list,i);
}
</code></pre><p>&#x6E32;&#x67D3;&#x7ED3;&#x679C;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e3291772fb38b8c3cfd8743.png" alt></p>
<hr>
<p>layout: post<br>
title: Ray Tracing in One Weekend Summary XVI - Testing all features<br>
date: 2020-01-30</p>
<hr>
<h1 class="mume-header" id="%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%9A%84%E6%B8%B2%E6%9F%93-1">&#x5C01;&#x9762;&#x56FE;&#x7684;&#x6E32;&#x67D3;</h1>

<pre data-role="codeBlock" data-info class="language-"><code>hittable *final() {
    int nb = 20;
    hittable **list = new hittable*[30];
    hittable **boxlist = new hittable*[10000];
    hittable **boxlist2 = new hittable*[10000];
    material *white = new lambertian( new constant_texture(vec3(0.73, 0.73, 0.73)));
    material *ground = new lambertian( new constant_texture(vec3(0.48, 0.83, 0.53)));
    int b = 0;
    for (int i = 0; i &lt; nb; i++) {
        for (int j = 0; j &lt; nb; j++) {
            float w = 100;
            float x0 = -1000 + i*w;
            float z0 = -1000 + j*w;
            float y0 = 0;
            float x1 = x0 + w;
            float y1 = 100*(random_double()+0.01);
            float z1 = z0 + w;
            boxlist[b++] = new box(vec3(x0,y0,z0), vec3(x1,y1,z1), ground);
        }
    }
    int l = 0;
    list[l++] = new bvh_node(boxlist, b, 0, 1);
    material *light = new diffuse_light( new constant_texture(vec3(7, 7, 7)));
    list[l++] = new xz_rect(123, 423, 147, 412, 554, light);
    vec3 center(400, 400, 200);
    list[l++] = new moving_sphere(center, center+vec3(30, 0, 0),
        0, 1, 50, new lambertian(new constant_texture(vec3(0.7, 0.3, 0.1))));
    list[l++] = new sphere(vec3(260, 150, 45), 50, new dielectric(1.5));
    list[l++] = new sphere(vec3(0, 150, 145), 50,
        new metal(vec3(0.8, 0.8, 0.9), 10.0));
    hittable *boundary = new sphere(vec3(360, 150, 145), 70, new dielectric(1.5));
    list[l++] = boundary;
    list[l++] = new constant_medium(boundary, 0.2,
        new constant_texture(vec3(0.2, 0.4, 0.9)));
    boundary = new sphere(vec3(0, 0, 0), 5000, new dielectric(1.5));
    list[l++] = new constant_medium(boundary, 0.0001,
        new constant_texture(vec3(1.0, 1.0, 1.0)));
    int nx, ny, nn;
    unsigned char *tex_data = stbi_load(&quot;earthmap.jpg&quot;, &amp;nx, &amp;ny, &amp;nn, 0);
    material *emat =  new lambertian(new image_texture(tex_data, nx, ny));
    list[l++] = new sphere(vec3(400, 200, 400), 100, emat);
    texture *pertext = new noise_texture(0.1);
    list[l++] =  new sphere(vec3(220, 280, 300), 80, new lambertian( pertext ));
    int ns = 1000;
    for (int j = 0; j &lt; ns; j++) {
        boxlist2[j] = new sphere(
            vec3(165*random_double(), 165*random_double(), 165*random_double()),
            10, white);
    }
    list[l++] = new translate(new rotate_y(
        new bvh_node(boxlist2, ns, 0.0, 1.0), 15), vec3(-100,270,395));
    return new hittable_list(list,l);
}
</code></pre><p>&#x5206;&#x8FA8;&#x7387;600x600</p>
<p>sample:500</p>
<hr>
<p>&#x6E32;&#x67D3;&#x7ED3;&#x679C;&#x5982;&#x4E0B;</p>
<p><img src="https://pic.downk.cc/item/5e32cbe82fb38b8c3c03af36.png" alt></p>

      </div>
      
      
    
    
    
    
    
    
    
    
  
    </body></html>