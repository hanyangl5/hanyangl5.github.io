I"Ì<h1 id="çƒä½“-è¡¨é¢æ³•çº¿-å¤šç‰©ä½“">çƒä½“ è¡¨é¢æ³•çº¿ å¤šç‰©ä½“</h1>

<hr />

<h3 id="hittableç±»">hittableç±»</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef HITTABLEH
#define HITTABLEH

#include "ray.h"

struct hit_record {
    float t;
    vec3 p;
    vec3 normal;
};

class hittable  {
    public:
        virtual bool hit(
            const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const = 0;
};

#endif
</code></pre></div></div>

<p>hittableæ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå…¶ä¸­å®šä¹‰äº†æ•°æ®ç±»å‹hit_recordï¼ŒåŒ…å«å…‰çº¿ä¸è¡¨é¢çš„äº¤ç‚¹pï¼Œäº¤ç‚¹çš„æ³•çº¿æ–¹å‘normalï¼Œtç”¨äºè®°å½•ç¦»è§‚å¯Ÿè€…æœ€è¿‘çš„ç‚¹</p>

<p>hitå‡½æ•°æ¥æ”¶rayç±»å‹å˜é‡rï¼Œt_minï¼Œt_maxï¼Œå¹¶å°†hitä¿¡æ¯ä¿å­˜åœ¨recä¸­</p>

<hr />

<h3 id="çƒä½“ç±»-sphereh">çƒä½“ç±» sphere.h</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef SPHEREH
#define SPHEREH

#include "hittable.h"

class sphere: public hittable  {
    public:
        sphere() {}
        sphere(vec3 cen, float r) : center(cen), radius(r)  {};
        virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const;
        vec3 center;
        float radius;
};

bool sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    float a = dot(r.direction(), r.direction());
    float b = dot(oc, r.direction());
    float c = dot(oc, oc) - radius*radius;
    float discriminant = b*b - a*c;

    if (discriminant &gt; 0) {
        float temp = (-b - sqrt(discriminant))/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            return true;
        }
        temp = (-b + sqrt(discriminant)) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            return true;
        }
    }
    //no roots
    return false;
}


#endif
</code></pre></div></div>

<p>sphereç±»ç»§æ‰¿è‡ªhittableç±»çš„åˆå§‹åŒ–éœ€è¦çƒå¿ƒcentå’ŒåŠå¾„rä¸¤ä¸ªå˜é‡</p>

<p>hitå‡½æ•°ç”¨äºè®¡ç®—å…‰çº¿æ˜¯å¦ä¸çƒä½“ç›¸äº¤ï¼Œæ•°å­¦æ¨å¯¼å¦‚ä¸‹:</p>

<p>æˆ‘ä»¬é€šå¸¸ç”¨ <strong>(xâˆ’Cx)^2+(yâˆ’Cy)^2+(zâˆ’Cz)^2=R^2</strong> è¡¨ç¤ºçƒå¿ƒä¸º(Cx,Cy,Cz)çš„çƒä½“</p>

<p>æˆ‘ä»¬è®° <strong>C=(Cx,Cy,Cz) P=(x,y,z)</strong></p>

<p>é‚£ä¹ˆ <strong>dot(P-C,P-C)=(xâˆ’Cx)^2+(yâˆ’Cy)^2+(zâˆ’Cz)^2=R^2</strong></p>

<p>ç‚¹Pçš„åæ ‡å¯ä»¥ç”¨rayç±»ä¸­çš„point_at_parameterå‡½æ•°å¾—åˆ°ï¼Œå³ <strong>p(t)=A+tâˆ—B</strong></p>

<p>æ”¹å†™æ–¹ç¨‹å¦‚ä¸‹</p>

<p><strong>dot((p(t)âˆ’C),(p(t)âˆ’C))=dot((A+tâˆ—Bâˆ’C),(A+tâˆ—Bâˆ’C))=R^2</strong></p>

<p><strong>t^2â‹…dot(B,B)+2tâ‹…dot(B,Aâˆ’C)+dot(Aâˆ’C,Aâˆ’C)âˆ’R^2=0</strong></p>

<p>æˆ‘ä»¬è¦åšçš„å°±æ˜¯å¯¹ä¸åŒçš„tæ±‚å‡ºæ­¤æ–¹ç¨‹çš„è§£ï¼ˆä»£ç ä¸­åœ¨æ–¹ç¨‹çš„ç³»æ•°ä¸Šç¨æœ‰å˜åŒ–ï¼Œä½†ä¸å½±å“ç»“æœçš„æ­£è´Ÿï¼‰</p>

<p><img src="https://raytracing.github.io/images/fig-1-05-1.jpg" alt="" /></p>

<p>åˆ¤åˆ«å¼(b^2-4<em>a</em>c)&lt;0ï¼Œæ–¹ç¨‹æ— å®æ•°è§£æ—¶ï¼šå…‰çº¿ä¸çƒä½“æ— äº¤ç‚¹ï¼Œè¾“å‡ºèƒŒæ™¯è‰²</p>

<p>åˆ¤åˆ«å¼&gt;0æ—¶ï¼Œæ–¹ç¨‹æœ‰ä¸¤ä¸ªè§£r1ï¼Œr2ï¼Œæˆ‘ä»¬é¦–å…ˆè€ƒå¯Ÿè·ç¦»è§‚å¯Ÿç‚¹è§’è¾ƒè¿‘çš„äº¤ç‚¹ï¼Œå³æ–¹ç¨‹è§£ä¸­è¾ƒå°çš„ä¸€ä¸ªï¼Œå› ä¸ºå…‰çº¿ä¸ä¼šç©¿è¿‡ç‰©ä½“ï¼Œåªä¼šç…§å°„åˆ°çƒä½“ä¸Šè¾ƒè¿‘çš„ç‚¹ï¼ˆæˆ‘ä»¬å‡è®¾ç‰©ä½“æ˜¯å®Œå…¨ä¸é€æ˜çš„ï¼‰ï¼Œè®°å½•äº¤ç‚¹çš„tå€¼ï¼Œåæ ‡pï¼Œå’Œæ³•çº¿æ–¹å‘n</p>

<hr />

<h3 id="hittablelistç±»-å¤šç‰©ä½“">hittablelistç±» å¤šç‰©ä½“</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef HITTABLELISTH
#define HITTABLELISTH

#include "hittable.h"

class hittable_list: public hittable {
    public:
        hittable_list() {}
        hittable_list(hittable **l, int n) {list = l; list_size = n; }
        virtual bool hit(
            const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const;
        hittable **list;
        int list_size;
};

bool hittable_list::hit(const ray&amp; r, float t_min, float t_max,
                        hit_record&amp; rec) const {

    hit_record temp_rec;
    bool hit_anything = false;
    double closest_so_far = t_max;
    for (int i = 0; i &lt; list_size; i++) {
        if (list[i]-&gt;hit(r, t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }
    return hit_anything;
}

#endif
</code></pre></div></div>

<p>hittablelistç±»ä¼šè®¡ç®—å‡ºå…‰çº¿ä¸å¤šä¸ªçƒä½“æœ€è¿‘çš„äº¤ç‚¹</p>

<hr />

<p>ä¿®æ”¹åçš„mainå‡½æ•°</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "svpng.inc"
#include "sphere.h"
#include "hittablelist.h"
#include&lt;cfloat&gt;

vec3 color(const ray&amp; r, hittable *world) {
    hit_record rec;
    if (world-&gt;hit(r, 0.0, FLT_MAX, rec)) {
        return 0.5*vec3(rec.normal.x()+1, rec.normal.y()+1, rec.normal.z()+1);
    }
    else{
    vec3 unit_direction = unit_vector(r.direction());
    float t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);   
    }
}

int main() {

    int nx=600,ny=300;
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen("test.png", "wb");

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);

    hittable *list[2];
    list[0] = new sphere(vec3(0,0,-1), 0.5);
    list[1] = new sphere(vec3(0,-100.5,-1), 100);
    hittable *world = new hittable_list(list,2);
    
    for (int j = ny-1; j &gt;= 0; j--)
        for (int i = 0; i &lt; nx; i++) {

            float u = float(i) / float(nx);
            float v = float(j) / float(ny);
            ray r(origin, lower_left_corner + u*horizontal + v*vertical);
            vec3 pap = r.point_at_parameter(2.0);
            vec3 col = color(r, world);
            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */
        }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
</code></pre></div></div>

<p>åœ¨colorå‡½æ•°ä¸­ï¼Œå¦‚æœå…‰çº¿ç…§å°„åˆ°äº†çƒä½“ä¸Šï¼Œä¼šæ ¹æ®äº¤ç‚¹çš„æ³•çº¿æ–¹å‘ï¼Œæ”¹å˜é¢œè‰²çš„å€¼</p>

<hr />

<p>äº§ç”Ÿçš„å›¾ç‰‡å¦‚ä¸‹</p>

<p><img src="https://pic.downk.cc/item/5e2180132fb38b8c3c398a66.png" alt="" /></p>
:ET