I" +<p>#æè´¨</p>

<hr />

<h3 id="æè´¨ç±»">æè´¨ç±»</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class material{
public:
    virtual bool scatter(
        const ray&amp; r_in,
        const hit_record&amp; rec,
        vec3&amp; attenuation,
        ray&amp; scattered) const = 0;
};
</code></pre></div></div>

<p>scatterå‡½æ•°æ¥å—ä¸€æ¡å…‰çº¿r_inï¼Œç¢°æ’è®°å½•recï¼Œè¡°å‡attenuationï¼Œå’Œæ•£å°„åçš„å…‰çº¿scattered</p>

<p>åŒæ—¶è¦ä»¥ä¸‹ä»£ç ä¸­ç¨åšä¿®æ”¹</p>

<p>sphere.h</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef SPHEREH
#define SPHEREH

#include "hittable.h"

class sphere: public hittable  {
    public:
        sphere() {}
        sphere(vec3 cen, float r, material *m) : center(cen), radius(r), mat_ptr(m)  {};
        virtual bool hit(const ray&amp; r, float tmin, float tmax, hit_record&amp; rec) const;
        vec3 center;
        float radius;
        material *mat_ptr; /* NEW */
};

bool sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    float a = dot(r.direction(), r.direction());
    float b = dot(oc, r.direction());
    float c = dot(oc, oc) - radius*radius;
    float discriminant = b*b - a*c;
    if (discriminant &gt; 0) {
        float temp = (-b - sqrt(discriminant))/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; /* NEW */
            return true;
        }
        temp = (-b + sqrt(discriminant)) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; /* NEW */
            return true;
        }
    }
    return false;
}
#endif
</code></pre></div></div>

<p>hittable.h</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef HITTABLEH
#define HITTABLEH
#include "ray.h"

class material;

struct hit_record {
    float t;
    vec3 p;
    vec3 normal;
    material *mat_ptr;
};

class hittable  {
    public:
        virtual bool hit(
            const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const = 0;
};

#endif
</code></pre></div></div>

<p>æ·»åŠ ç±»æˆå‘˜mat_ptrç”¨äºåœ¨çƒä½“åˆå§‹åŒ–æ—¶æŒ‡å®šæè´¨</p>

<hr />

<h3 id="æ¼«åå°„-diffuse">æ¼«åå°„ diffuse</h3>

<p>æˆ‘ä»¬ç”¨lambertå…‰ç…§æ¨¡å‹æ¨¡æ‹Ÿæ¼«åå°„ï¼Œlambertæ¨¡å‹ç”¨äºçº¯ç²¹çš„æ¼«åå°„è¡¨é¢çš„ç‰©ä½“ï¼Œå…‰æºç…§å°„åˆ°ç‰©ä½“è¡¨é¢åï¼Œå‘å››é¢å…«æ–¹åå°„ï¼Œäº§ç”Ÿæ¼«åå°„æ•ˆæœã€‚</p>

<p><img src="https://raytracing.github.io/images/fig-1-08-1.jpg" alt="" /></p>

<p>å¦‚å›¾æ‰€ç¤ºï¼Œå…‰çº¿åœ¨ç…§å°„åˆ°å¹³é¢ä¸Šæ—¶åå°„çš„æ–¹å‘æ˜¯éšæœºçš„</p>

<p>random.h</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vec3 random_in_unit_sphere() {
    vec3 p;
    do {
        p = 2.0*vec3(random_double(), random_double(), random_double()) - vec3(1,1,1);
    } while (p.squared_length() &gt;= 1.0);
    return p;
}
</code></pre></div></div>
<p>random_in_unit_sphereç”Ÿæˆä¸€ä¸ªé•¿åº¦ä¸º1çš„éšæœºå‘é‡</p>

<p><img src="https://raytracing.github.io/images/fig-1-08-2.jpg" alt="" /></p>

<p>è¡¨é¢æ³•çº¿ä¸º <strong>n</strong>ï¼Œå…‰çº¿ä¸è¡¨é¢äº¤ç‚¹ <strong>p</strong>ï¼Œéšæœºå‘é‡ <strong>random</strong>ï¼Œ<strong>p+n+random</strong>å°±æ˜¯æ¼«åå°„çš„æ–¹å‘</p>

<p>æ·»åŠ materialçš„å­ç±»lambertian</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class lambertian : public material {
    public:
        lambertian(const vec3&amp; a) : albedo(a) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const {
            vec3 target = rec.p + rec.normal + random_in_unit_sphere();
            scattered = ray(rec.p, target-rec.p);
            attenuation = albedo;
            return true;
        }
        vec3 albedo;
};
</code></pre></div></div>

<p>è¿”å›å€¼ä¸ºtrueï¼Œscatteredä¸ºåå°„å…‰çº¿</p>

<hr />

<h3 id="é«˜å…‰åå°„-specular">é«˜å…‰åå°„ specular</h3>

<p>è®¡ç®—åå°„æ–¹å‘ï¼Œæ•°å­¦æ¨å¯¼å¦‚ä¸‹</p>

<p><img src="https://raytracing.github.io/images/fig-1-09-1.jpg" alt="" /></p>

<p>æˆ‘ä»¬å·²çŸ¥å…¥å°„æ–¹å‘ <strong>v</strong>ï¼Œè¡¨é¢æ³•çº¿æ–¹å‘ <strong>n</strong>ä¸”é•¿åº¦ä¸º1ï¼Œvåœ¨næ–¹å‘ä¸Šçš„æŠ•å½±ä¸º <strong>dot(n,v)</strong>ï¼Œåå°„æ–¹å‘å³ä¸º <strong>v-2Â·nÂ·dot(v,n)</strong></p>

<p>è®¡ç®—åå°„æ–¹å‘çš„å‡½æ•°reflect</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vec3 reflect(const vec3&amp; v, const vec3&amp; n) {
    return v - 2*dot(v,n)*n;
}
</code></pre></div></div>

<p>æ·»åŠ materialçš„è‡ªç±»metal</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class metal : public material {
    public:
        metal(const vec3&amp; a) : albedo(a) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec,
                             vec3&amp; attenuation, ray&amp; scattered) const {
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            scattered = ray(rec.p, reflected);
            attenuation = albedo;
            return (dot(scattered.direction(), rec.normal) &gt; 0);
        }
        vec3 albedo;
};
</code></pre></div></div>

<hr />

<p>ä¿®æ”¹åçš„mainå‡½æ•°</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include "svpng.inc"
#include "sphere.h"
#include "hittablelist.h"
#include "camera.h"
#include "random.h"
#include "material.h"
#include&lt;cfloat&gt;

vec3 color(const ray&amp; r, hittable *world, int depth) {
    hit_record rec;
    if (world-&gt;hit(r, 0.001, FLT_MAX, rec)) {
        ray scattered;
        vec3 attenuation;
        if (depth &lt; 50 &amp;&amp; rec.mat_ptr-&gt;scatter(r, rec, attenuation, scattered)) {
            return attenuation*color(scattered, world, depth+1);
        }
        else {
            return vec3(0,0,0);
        }
    }
    else{
    vec3 unit_direction = unit_vector(r.direction());
    float t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);   
    }
}

int main() {

    int nx=600,ny=300,ns=100;
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen("test.png", "wb");

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);
    camera cam;
    hittable *list[4];
    list[0] = new sphere(vec3(0,0,-1), 0.5, new lambertian(vec3(0.8, 0.3, 0.3)));
    list[1] = new sphere(vec3(0,-100.5,-1), 100, new lambertian(vec3(0.8, 0.8, 0.0)));
    list[2] = new sphere(vec3(1,0,-1), 0.5, new lambertian(vec3(0.2,0.2,0.8)));
    list[3] = new sphere(vec3(-1,0,-1), 0.5, new metal(vec3(0.8, 0.8, 0.8)));
    hittable *world = new hittable_list(list,4);

    for (int j = ny-1; j &gt;= 0; j--){
        for (int i = 0; i &lt; nx; i++) {
            vec3 col(0,0,0);
            for(int s = 0; s &lt; ns ; s++){
                float u = float(i + random_double()) / float(nx);
                float v = float(j + random_double()) / float(ny);
                ray r = cam.get_ray(u,v);               
                col += color(r, world, 0);           
            }
            col /= float(ns);
            col = vec3( sqrt(col[0]), sqrt(col[1]), sqrt(col[2]) );
            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */   
        }
    }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
</code></pre></div></div>

<p>åœ¨colorå‡½æ•°ä¸­ï¼Œdepthçš„å€¼ä¸ºå…‰çº¿åå°„çš„æ¬¡æ•°</p>

<p>depth=0</p>

<p><img src="https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4570.png" alt="" /></p>

<p>depth=1</p>

<p><img src="https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4572.png" alt="" /></p>

<p>depth=2</p>

<p><img src="https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4574.png" alt="" /></p>

<p>depth=1000</p>

<p><img src="https://pic.downk.cc/item/5e22de9e2fb38b8c3c59f22f.png" alt="" /></p>

<p>åå°„æ¬¡æ•°è¶Šå¤šï¼Œå›¾åƒè¶Šç†æƒ³</p>

<p>åœ¨è¿­ä»£è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å‡è®¾å…‰çº¿æ— è¡°å‡ï¼Œattenuationå€¼ä¸å˜ï¼Œä¸ºç‰©ä½“è¡¨é¢çš„é¢œè‰²ï¼Œå› ä¸ºattenuation&lt;0ï¼Œåå°„æ¬¡æ•°è¶Šå¤šï¼Œå…‰çº¿é¢œè‰²çš„rgbå€¼è¶Šæ¥è¶Šå°ï¼Œè¶‹è¿‘ä¸0ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆåœ¨çƒä½“çš„äº¤ç•Œå¤„äº§ç”Ÿé˜´å½±çš„åŸå› </p>

<hr />

<h3 id="gamma-correction">gamma correction</h3>

<p><a href="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/#gamma">ä¸€ç¯‡å¯¹gammaçŸ«æ­£çš„ä»‹ç»</a></p>

<p>äººçœ¼å¯¹ç°é˜¶çš„æ„ŸçŸ¥ä¸æ˜¯çº¿æ€§çš„ï¼Œè€Œæ˜¯ç±»ä¼¼1/Î±çš„æ›²çº¿ï¼Œæ‰€ä»¥æˆ‘ä»¬ç”Ÿæˆçš„å›¾ç‰‡åœ¨æŸäº›åœ°æ–¹çœ‹èµ·æ¥ä¼šè¿‡æš—æˆ–è¿‡äº®</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>col = vec3( sqrt(col[0]), sqrt(col[1]), sqrt(col[2]) );
</code></pre></div></div>

<p>ä»¥ä¸Šä»£ç çš„ä½œç”¨æ˜¯å¯¹é¢œè‰²ä¿¡æ¯è¿›è¡Œä¸€ä¸ªéçº¿æ€§çš„æ˜ å°„</p>

<hr />

<h3 id="shadow-acne-problem">shadow acne problem</h3>

<p>ä¸€äº›å…³äºæ­¤é—®é¢˜çš„æè¿°å’Œè§£é‡Š</p>

<p><a href="https://www.zhihu.com/question/49090321">zhihu</a></p>

<p><a href="https://computergraphics.stackexchange.com/questions/2192/cause-of-shadow-acne">cause-of-shadow-acne -stackoverflow</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (world-&gt;hit(r, 0.001, MAXFLOAT, rec)) {...}
</code></pre></div></div>

<p>è§£å†³æ–¹æ³•æ˜¯ï¼Œåœ¨ä¸Šé¢è¯­å¥ä¸­ï¼Œå°†t_minåŠ ä¸Šä¸€ä¸ªbiasï¼ˆ0.001ï¼‰</p>

<p>æ¸²æŸ“å‡ºçš„å›¾åƒå¯¹æ¯”</p>

<p><img src="https://pic.downk.cc/item/5e22fcee2fb38b8c3c5d2905.png" alt="" /></p>

<p><img src="https://pic.downk.cc/item/5e22de9e2fb38b8c3c59f22f.png" alt="" /></p>

<hr />

<h3 id="fuzz">fuzz</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class metal : public material {
    public:
        metal(const vec3&amp; a, float f) : albedo(a) { /*NEW*/
            if (f &lt; 1) fuzz = f; else fuzz = 1;
        }

        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec,
                             vec3&amp; attenuation, ray&amp; scattered) const {
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            scattered = ray(rec.p, reflected + fuzz*random_in_unit_sphere()); /*NEW*/
            attenuation = albedo;
            return (dot(scattered.direction(), rec.normal) &gt; 0);
        }
        vec3 albedo;
        float fuzz; /*NEW*/
};
</code></pre></div></div>

<p>ä¸ºmetalæè´¨æ·»åŠ æ¨¡ç³Šæ•ˆæœ</p>

<p>æ•ˆæœå¦‚ä¸‹ï¼š</p>

<p><img src="https://pic.downk.cc/item/5e2306652fb38b8c3c5e1354.png" alt="" /></p>

:ET