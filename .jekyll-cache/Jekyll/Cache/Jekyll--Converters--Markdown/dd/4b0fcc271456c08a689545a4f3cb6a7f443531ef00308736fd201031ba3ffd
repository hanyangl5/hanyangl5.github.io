I"›<h1 id="çƒŸé›¾">çƒŸé›¾</h1>

<p>å…‰ç…§å°„åˆ°volumeä¸Šæ—¶ï¼Œæ—¢æœ‰å¯èƒ½ç›´æ¥ç©¿è¿‡ï¼Œåˆå¯èƒ½å‘ç”Ÿåå°„ï¼ŒæŠ˜å°„ã€‚å…‰çº¿åœ¨çƒŸé›¾ä½“ä¸­èƒ½ä¼ æ’­å¤šè¿œï¼Œæ˜¯ç”±volumeçš„å¯†åº¦å†³å®šçš„ï¼Œå¯†åº¦è¶Šé«˜ï¼Œå…‰çº¿ç©¿é€æ€§è¶Šå·®ï¼Œå…‰çº¿ä¼ æ’­çš„è·ç¦»ä¹Ÿè¶ŠçŸ­ã€‚</p>

<p>æˆ‘ä»¬åœ¨volumeçš„å†…éƒ¨æ·»åŠ ä¸€äº›éšæœºæ–¹å‘çš„è¡¨é¢æ¥å®ç°è¿™ç§æ•ˆæœ</p>

<p>å½“å…‰çº¿é€šè¿‡ä½“ç§¯æ—¶ï¼Œå®ƒå¯èƒ½åœ¨ä»»ä½•ç‚¹æ•£å°„ã€‚ å…‰çº¿åœ¨ä»»ä½•å°è·ç¦»dLä¸­æ•£å°„çš„æ¦‚ç‡ä¸ºï¼š</p>

<p>æ¦‚ç‡ <strong>p=C*dL</strong>ï¼Œå…¶ä¸­Cä¸volumeå¯†åº¦æˆæ­£æ¯”ã€‚</p>

<hr />

<p>iostropic.h</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class isotropic : public material {
    public:
        isotropic(texture *a) : albedo(a) {}
        virtual bool scatter(
            const ray&amp; r_in,
            const hit_record&amp; rec,
            vec3&amp; attenuation,
            ray&amp; scattered) const {

            scattered = ray(rec.p, random_in_unit_sphere());
            attenuation = albedo-&gt;value(rec.u, rec.v, rec.p);
            return true;
        }
        texture *albedo;
};
</code></pre></div></div>

<p>åœ¨isotropic.hä¸­ï¼Œvolumeä¸­çš„æ•£å°„æ–¹å‘æ˜¯éšæœºæ–¹å‘ï¼Œä¸æ¼«åå°„ä¸åŒçš„æ˜¯ï¼Œæ¼«åå°„çš„æ•£å°„å…‰çº¿ä¸å¯èƒ½æŒ‡åˆ°ç‰©ä½“å†…éƒ¨ï¼Œå®ƒä¸€å®šæ˜¯æ•£å°„åˆ°è¡¨é¢å¤–ï¼Œisotropicæè´¨çš„æ•£å°„å…‰çº¿å¯ä»¥æ²¿åŸæ¥çš„æ–¹å‘ä¸€å¾€å‰ï¼Œä»¥æ­¤å®ç°é€å…‰æ€§</p>

<hr />

<p>constant_medium.h</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class constant_medium : public hittable {
    public:
        constant_medium(hittable *b, float d, texture *a) : boundary(b), density(d) {
            phase_function = new isotropic(a);
        }
        virtual bool hit(
            const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const;
        virtual bool bounding_box(float t0, float t1, aabb&amp; box) const {
            return boundary-&gt;bounding_box(t0, t1, box);
        }
        hittable *boundary;
        float density;
        material *phase_function;
};

bool constant_medium::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec)
const {
    const bool enableDebug = false;//ç”¨äºdebug
    bool debugging = enableDebug &amp;&amp; random_double() &lt; 0.00001;

    hit_record rec1, rec2;

    if (boundary-&gt;hit(r, -FLT_MAX, FLT_MAX, rec1)) {
        if (boundary-&gt;hit(r, rec1.t+0.0001, FLT_MAX, rec2)) {

            if (debugging) std::cerr &lt;&lt; "\nt0 t1 " &lt;&lt; rec1.t &lt;&lt; " " &lt;&lt; rec2.t &lt;&lt; '\n';

            if (rec1.t &lt; t_min)
                rec1.t = t_min;

            if (rec2.t &gt; t_max)
                rec2.t = t_max;

            if (rec1.t &gt;= rec2.t)
                return false;

            if (rec1.t &lt; 0)
                rec1.t = 0;

            float distance_inside_boundary = (rec2.t - rec1.t)*r.direction().length();
            float hit_distance = -(1/density) * log(random_double());

            if (hit_distance &lt; distance_inside_boundary) {

                rec.t = rec1.t + hit_distance / r.direction().length();
                rec.p = r.point_at_parameter(rec.t);

                if (debugging) {
                    std::cerr &lt;&lt; "hit_distance = " &lt;&lt;  hit_distance &lt;&lt; '\n'
                              &lt;&lt; "rec.t = " &lt;&lt;  rec.t &lt;&lt; '\n'
                              &lt;&lt; "rec.p = " &lt;&lt;  rec.p &lt;&lt; '\n';
                }

                rec.normal = vec3(1,0,0);  // arbitrary
                rec.mat_ptr = phase_function;
                return true;
            }
        }
    }
    return false;
}
</code></pre></div></div>

<p>hitå‡½æ•°é‡Œé¢æ˜¯ä¸€äº›è¾¹ç•Œåˆæ³•æ€§æ£€æµ‹</p>

<h3 id="test">test</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hittable *cornell_smoke() {
    hittable **list = new hittable*[8];
    int i = 0;
    material *red = new lambertian(new constant_texture(vec3(0.65, 0.05, 0.05)));
    material *white = new lambertian(new constant_texture(vec3(0.73, 0.73, 0.73)));
    material *green = new lambertian(new constant_texture(vec3(0.12, 0.45, 0.15)));
    material *light = new diffuse_light(new constant_texture(vec3(15, 15, 15)));

    list[i++] = new flip_normals(new yz_rect(0, 555, 0, 555, 555, green));
    list[i++] = new yz_rect(0, 555, 0, 555, 0, red);
    list[i++] = new xz_rect(213, 343, 227, 332, 554, light);
    list[i++] = new flip_normals(new xz_rect(0, 555, 0, 555, 555, white));
    list[i++] = new xz_rect(0, 555, 0, 555, 0, white);
    list[i++] = new flip_normals(new xy_rect(0, 555, 0, 555, 555, white));

    hittable *b1 = new translate(new rotate_y(new box(vec3(0, 0, 0), vec3(165, 165, 165), white), -18),vec3(130,0,65));
    hittable *b2 = new translate(new rotate_y(new box(vec3(0, 0, 0), vec3(165, 330, 165), white),  15),vec3(265,0,295));

    list[i++] = new constant_medium(b1, 0.01, new constant_texture(vec3(1.0, 1.0, 1.0)));
    list[i++] = new constant_medium(b2, 0.01, new constant_texture(vec3(0.0, 0.0, 0.0)));
        
    return new hittable_list(list,i);
}
</code></pre></div></div>

<p>æ¸²æŸ“ç»“æœå¦‚ä¸‹</p>

<p><img src="https://pic.downk.cc/item/5e3291772fb38b8c3cfd8743.png" alt="" /></p>
:ET