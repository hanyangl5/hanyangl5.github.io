I"—<h1 id="çº¹ç†æ˜ å°„">çº¹ç†æ˜ å°„</h1>

<p>çº¹ç†æ˜ å°„ï¼Œå°±æ˜¯é€šè¿‡è¯»å–ä¸€å¼ å›¾ç‰‡ï¼Œä½¿ç”¨uvæ˜ å°„çš„æ–¹æ³•ï¼Œç›´æ¥å°†ä¸€å¼ å›¾ç‰‡çš„çº¹ç†ç»˜åˆ¶åœ¨ç‰©ä½“è¡¨é¢ã€‚</p>

<p>ç›´æ¥çš„æ–¹æ³•æ˜¯ç¼©æ”¾uvï¼Œuvæ˜¯[0,1]ä¹‹é—´çš„floatã€‚è€Œåƒç´ è‚¯å®šå¤§äºè¿™ä¸ªåŒºé—´ï¼Œæ‰€ä»¥éœ€è¦è¿›è¡Œç¼©æ”¾ï¼Œç”¨(i,j)è¡¨ç¤ºå½“å‰åƒç´ ï¼Œnxå’Œnyè¡¨ç¤ºçº¹ç†çš„åˆ†è¾¨ç‡ï¼Œæ‰€ä»¥å¯¹äºä»»æ„åƒç´ (i,j)ä½ç½®ï¼Œå¯¹åº”çš„uvåæ ‡å°±æ˜¯</p>

<p><strong>u = i / (nx - 1)</strong></p>

<p><strong>v = j / (ny - 1)</strong></p>

<hr />

<h3 id="è¯»å–çº¹ç†">è¯»å–çº¹ç†</h3>

<p><a href="https://github.com/nothings/stb/blob/master/stb_image.h"></a></p>

<p>æˆ‘ä»¬ç”¨stb_imageè¿™ä¸ªåº“æ¥è¯»å–å›¾ç‰‡çº¹ç†ï¼Œåœ¨ä½¿ç”¨å‰ï¼Œéœ€è¦è¿›è¡Œåˆå§‹åŒ–</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
</code></pre></div></div>

<p>å¯ä»¥ç”¨stbi_loadå‡½æ•°å°†çº¹ç†æ•°æ®å­˜å…¥dataä¸­</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Basic usage
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &amp;x, &amp;y, &amp;n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
</code></pre></div></div>

<p>xï¼Œyæ˜¯å›¾ç‰‡çš„å®½ï¼Œé«˜</p>

<hr />

<h3 id="æŠ•å½±å‡½æ•°">æŠ•å½±å‡½æ•°</h3>

<p>ä½¿ç”¨çƒçš„é¡¶ç‚¹æ¥æ±‚çƒé¢çš„çº¹ç†åæ ‡ï¼Œç¤ºæ„å›¾å¦‚ä¸‹</p>

<p><img src="https://pic.downk.cc/item/5e3111562fb38b8c3cde3bf4.jpg" alt="" /></p>

<p>å¯¹äº¤ç‚¹P(x,y,z)å’ŒåŠå¾„rï¼Œæ˜ å°„æˆçƒåæ ‡çš„Î¸å’ŒÏ•ã€‚æœ‰ä»¥ä¸‹å…¬å¼</p>

<p><strong>x=r*cosÎ¸cosÏ•</strong></p>

<p><strong>y=r*sinÎ¸</strong></p>

<p><strong>z=r*cosÎ¸sinÏ•</strong></p>

<p>è®¾ <strong>r=1</strong>ï¼Œåˆ™</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>float theta = asin(p.y());
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>float phi = atan2(p.z(), p.x());
</code></pre></div></div>

<p>æ¥ä¸‹æ¥æˆ‘ä»¬è¦å°†Ï•ï¼ŒÎ¸æ˜ å°„åˆ°(0,1)å†…</p>

<p>çº¹ç†åæ ‡çš„uå¯¹åº”Ï•ï¼ŒÏ•çš„èŒƒå›´æ˜¯ä»[-Ï€,Ï€]ï¼Œæ˜ å°„åˆ°[0,1]ä¹‹é—´ï¼Œå³ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>u = float(1 - (phi + M_PI) / (2 * M_PI));
</code></pre></div></div>

<p>ä¸Šé¢é™¤äº†ä¸ª1æ˜¯é¢ å€’ä¸€ä¸‹ï¼Œä»¥è®©çƒé¢å›¾ç‰‡å‘ä¸Šã€‚</p>

<p>vå€¼å¯¹åº”Î¸ï¼ŒÎ¸çš„èŒƒå›´æ˜¯ä»[-Ï€/2,Ï€/2],æ˜ å°„åˆ°[0,1]ä¹‹é—´ï¼Œå³ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v = float((theta + M_PI / 2) / M_PI);
</code></pre></div></div>

<p>ç”±ä¸Šæ•´ç†æˆä¸€ä¸ªæ ¹æ®äº¤ç‚¹pæ±‚uvçš„å‡½æ•°ä¸ºï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void get_sphere_uv(const vec3&amp; p, float&amp; u, float&amp; v)
{
    float phi = atan2(p.z(), p.x());
    float theta = asin(p.y());
    u = float(1 - (phi + M_PI) / (2 * M_PI));
    v = float((theta + M_PI / 2) / M_PI);
}
</code></pre></div></div>

<p><strong>å¯¹äºç®€å•çš„å‡ ä½•å½¢çŠ¶ï¼Œå¦‚çƒå½¢ã€åœ†æŸ±æŠ•å½±å‡½æ•°æ˜¯å¯ä»¥ç”¨æ•°å­¦æ¨å¯¼çš„ï¼Œåœ¨å¸¸è§„æƒ…å†µä¸‹ï¼ŒæŠ•å½±å‡½æ•°é€šå¸¸åœ¨ç¾æœ¯å»ºæ¨¡é˜¶æ®µä½¿ç”¨ï¼Œå¹¶å°†æŠ•å½±ç»“æœå­˜å‚¨äºé¡¶ç‚¹æ•°æ®ä¸­ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨è½¯ä»¶å¼€å‘è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¸ä¼šå»ç”¨æŠ•å½±å‡½æ•°å»è®¡ç®—å¾—åˆ°æŠ•å½±ç»“æœï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨åœ¨ç¾æœ¯å»ºæ¨¡è¿‡ç¨‹ä¸­ï¼Œå·²ç»å­˜å‚¨åœ¨æ¨¡å‹é¡¶ç‚¹æ•°æ®ä¸­çš„æŠ•å½±ç»“æœ â€” Real-Time Rendering 3rd</strong></p>

<hr />

<h3 id="å›¾ç‰‡çº¹ç†ç±»">å›¾ç‰‡çº¹ç†ç±»</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef IMAGETEXTURE
#define IMAGETEXTURE

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#include "texture.h"

class image_texture : public texture {
    public:
        image_texture() {}
        image_texture(unsigned char *pixels, int A, int B)
            : data(pixels), nx(A), ny(B) {}
        virtual vec3 value(float u, float v, const vec3&amp; p) const;
        unsigned char *data; //çº¹ç†æ•°æ®
        int nx, ny; //çº¹ç†çš„é•¿ï¼Œå®½
};

//æå–dataæ•°æ®ä¸­æŒ‡å®šä½ç½®çš„rgbå€¼
vec3 image_texture::value(float u, float v, const vec3&amp; p) const {
     int i = (u) * nx;
     int j = (1-v) * ny - 0.001;
     if (i &lt; 0) i = 0;
     if (j &lt; 0) j = 0;
     if (i &gt; nx-1) i = nx-1;
     if (j &gt; ny-1) j = ny-1;
     float r = int(data[3*i + 3*nx*j]  ) / 255.0;
     float g = int(data[3*i + 3*nx*j+1]) / 255.0;
     float b = int(data[3*i + 3*nx*j+2]) / 255.0;
     return vec3(r, g, b);
}
#endif
</code></pre></div></div>

<hr />

<p>ä¿®æ”¹hittable.h</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void get_sphere_uv(const vec3&amp; p, float&amp; u, float&amp; v) {
    float phi = atan2(p.z(), p.x());
    float theta = asin(p.y());
    u = 1-(phi + M_PI) / (2*M_PI);
    v = (theta + M_PI/2) / M_PI;
}

struct hit_record {
    float t;  
    float u;
    float v;
    vec3 p;
    vec3 normal; 
    material *mat_ptr;
};
</code></pre></div></div>

<p>sphere.h</p>

<p>get_sphere_uvè·å–æ’å‡»ç‚¹çš„åæ ‡</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool sphere::hit(const ray&amp; r, float t_min, float t_max, hit_record&amp; rec) const {
    vec3 oc = r.origin() - center;
    float a = dot(r.direction(), r.direction());
    float b = dot(oc, r.direction());
    float c = dot(oc, oc) - radius*radius;
    float discriminant = b*b - a*c;
    if (discriminant &gt; 0) {
        
        float temp = (-b - sqrt(discriminant))/a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            get_sphere_uv((rec.p-center)/radius, rec.u, rec.v);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; 
            return true;
        }
        
         temp = (-b + sqrt(discriminant)) / a;
        if (temp &lt; t_max &amp;&amp; temp &gt; t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            get_sphere_uv((rec.p-center)/radius, rec.u, rec.v);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; 
            return true;
        }
    }
    return false;
}
</code></pre></div></div>

<p>material.h</p>

<p>åå°„æ±‚å–å›¾ç‰‡å¯¹åº”å‡ºçš„åƒç´ å€¼</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class lambertian : public material {
    public:
        lambertian(texture *a) : albedo(a) {}
        virtual bool scatter(const ray&amp; r_in, const hit_record&amp; rec, vec3&amp; attenuation, ray&amp; scattered) const  {
             vec3 target = rec.p + rec.normal + random_in_unit_sphere();
             scattered = ray(rec.p, target-rec.p, r_in.time());
             attenuation = albedo-&gt;value(rec.u, rec.v, rec.p);
             return true;
        }
        texture *albedo;
};
</code></pre></div></div>

<p>main.cpp</p>

<p>è¯»å–å¹¶ç”Ÿæˆçº¹ç†</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hittable* texture_spheres(){
    int nx, ny, nn;
    unsigned char *tex_data = stbi_load("earthmap.jpg", &amp;nx, &amp;ny, &amp;nn, 0);
    material *mat = new lambertian(new image_texture(tex_data, nx, ny));
    int n = 50;
    hittable **list = new hittable*[n+1];
    list[0] = new sphere(vec3(0,0, 0), 1, mat);
    return new hittable_list(list,1);
}
</code></pre></div></div>

<hr />

<p>æœ€ç»ˆæ¸²æŸ“çš„å›¾ç‰‡å¦‚ä¸‹</p>

<p><img src="https://pic.downk.cc/item/5e2e71af2fb38b8c3ca808d3.png" alt="" /></p>
:ET