I"x!<p>实验要求</p>

<ul>
  <li>将所给人脸照片文件夹作为班级人脸数据库，其中每人有五张图片。</li>
  <li>test文件下存储的是用来识别或认证的不属于数据库中的照片，每人有一张图片。</li>
  <li>将人脸识别的代码封装成一个函数，命名为facial_recognition，其输入是当前测试图片的路径，且函数要返回最相似的人的名字。</li>
  <li>将人脸认证的代码封装成一个函数，命名为facial_verification，其输入是数据库中想要比对的人脸id和当前的测试图片的路径，且函数要根据认证的结果，即返回字符串“True”或字符串“False”。</li>
  <li>定义人名列表，列表中每个元素是人名字符串（即类似于”张三”, “李四”），列表名为names，评测中用到的id值即为在names列表中的序号（从0开始）。</li>
  <li>最终考核结果标准是识别的准确率和时间，以及认证的四项标准。</li>
</ul>

<p>大作业的名字是人脸识别，但在阅读实验要求后可以看出是一个分类问题</p>

<p>笔者选用resnet152进行分类</p>

<ul>
  <li>项目结构如下</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    |main.py
    |Dataset.py

    |cuttrain
        |name1
            |name1_1.jpg
            |name1_2.jpg
            ...
        |name2
            |name2_1.jpg
            |name2_2.jpg
            ...
        ...
    |cuttest
        |name1
            |name1.jpg
        |name2
            |name2.jpg
</code></pre></div></div>

<ul>
  <li>定义get_name函数生成人名列表</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def get_name_list(path):
    names = []
    name_path = path
    for filename in os.listdir(name_path):
        temp = re.sub("[0-9_-]", "", filename)
        temp = temp.split('.')[0]
        names.append(temp)
    return names
</code></pre></div></div>

<ul>
  <li>导入所需要的库以及运行所需要的各项准备：</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import os
import torchvision.models as models
from PIL import Image, ImageDraw
import datetime
from torch.autograd import Variable
import torch
import cv2
import numpy as np
from facenet_pytorch import MTCNN, extract_face
import matplotlib.pyplot as plt
import re
from torchvision import transforms, datasets, models
device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
names = get_name_list('../数据库图片/')
</code></pre></div></div>

<ul>
  <li>构建dataset，重写__len__,<strong>getitem</strong></li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Dataset(torch.utils.data.Dataset):
    def __init__(self, root, list, transform=None):
        self.labellist = list
        self.root = root
        self.transform = transform

        self.images = []
        for files in os.listdir(self.root):
            for filename in os.listdir(os.path.join(root, files)):
                self.images.append(files+'/'+filename)

    def __len__(self):
        return len(self.images)

    def __getitem__(self, index):
        image_index = self.images[index]
        img_path = os.path.join(self.root, image_index)

        img = Image.open(img_path).convert('RGB')

        label = img_path.split('/')[-1].split('_')[0]
        label = re.sub("[A-Za-z0-9\!\%\[\]\, \.\-\_]", "", label)
        label = self.labellist.index(label)  # mapping
        if self.transform:
            img = self.transform(img)
        return img, label
</code></pre></div></div>

<ul>
  <li>数据预处理，将图像缩放为224x224，加入了随机反转和旋转</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data_transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomHorizontalFlip(p=0.5),
    transforms.RandomRotation(15),
    transforms.ToTensor()
])
</code></pre></div></div>

<ul>
  <li>加载训练集，验证集</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#get name list
names = get_name_list('cuttrain')

#load testset
train_dataset = Dataset(
    root="cuttrain/", list=names, transform=data_transform)
train_loader = torch.utils.data.DataLoader(
    train_dataset, batch_size=8, shuffle=True)
#load testset
test_dataset = Dataset(
    root="cuttest/", list=names, transform=data_transform)
test_loader = torch.utils.data.DataLoader(
    test_dataset, batch_size=8, shuffle=True)
print(len(train_dataset),len(test_dataset))

</code></pre></div></div>

<ul>
  <li>初始化模型和训练方法，fc层输出104维向量，损失函数为交叉熵，优化器为Adam</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#init neural network
net = models.resnet152(pretrained=True)

for param in net.parameters():
    param.requires_grad = False

net.fc = torch.nn.Sequential(
    torch.nn.Linear(2048, 256),
    torch.nn.Linear(256, 104)
)
net = net.to(device)
criterion = torch.nn.CrossEntropyLoss().to(device)
optimizer = torch.optim.Adam(net.parameters(), lr=0.0001,betas=(0.9, 0.999), eps=1e-08, weight_decay=0.01)
epochs = 30
PATH = 'models/resnet152_mtcnn.pth'
</code></pre></div></div>

<ul>
  <li>模型训练</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if not os.path.exists(PATH):
    print('start training')
    for epoch in range(epochs):
        running_loss = 0.0
        train_correct = 0
        train_total = 0
        for i, data in enumerate(train_loader, 0):
            step = (epoch, i)
            inputs, train_labels = data
            inputs, labels = Variable(
                inputs.cuda()), Variable(train_labels.cuda())
            optimizer.zero_grad()
            outputs = net(inputs)
            _, train_predicted = torch.max(outputs.data, 1)
            train_correct += (train_predicted == labels.data).sum()
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            running_loss += loss.item()
            train_total += labels.size(0)
        print('train %d epoch loss: %.3f  acc: %.3f ' % (
            epoch + 1, running_loss / train_total, 100 * train_correct / train_total))
        # 模型测试
        correct = 0
        test_loss = 0.0
        test_total = 0
        net.eval()
        for data in test_loader:
            images, labels = data
            images, labels = Variable(
                images.cuda()), Variable(labels.cuda())
            outputs = net(images)
            _, predicted = torch.max(outputs.data, 1)
            loss = criterion(outputs, labels)
            test_loss += loss.item()
            test_total += labels.size(0)
            correct += (predicted == labels.data).sum()
        print('test  %d epoch loss: %.3f  acc: %.3f ' %
                (epoch + 1, test_loss / test_total, 100 * correct / test_total))
    torch.save(net, PATH)
    print("训练结束...")
</code></pre></div></div>

<ul>
  <li>测试</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#load model
net = torch.load(PATH)
print('load model')

# facial_recognition
starttime = datetime.datetime.now()
right = 0
wrong = 0

for item in os.listdir("cuttest"):
    test_path = "cuttest/" + item
    if facial_recognition(test_path) == item:
        right += 1
    else:
        wrong += 1

accuracy = right / (right+wrong)
endtime = datetime.datetime.now()

print("人脸识别的考察结果：")
print("人脸识别的准确率是:", accuracy)
print("整个人脸识别的运行时间是：", (endtime-starttime).seconds, "s")

# facial_verification

tp = 0
tn = 0
fp = 0
fn = 0

for name in names:
    test_path = "cuttest/" + name+"/" + name + ".jpg"
    for id in range(len(names)):
        result = facial_verification(id, test_path)
        if name == names[id] and result == "True":
            tp += 1
        elif name == names[id] and result == "False":
            fn += 1
        elif name != names[id] and result == "False":
            tn += 1
        else:
            fp += 1

print("人脸认证的考察结果:")
print("精度:", tp/(tp+fp))
print("回归率:", tp/(tp+fn))
print("特异性:", tn/(tn+fp))
print("F1值:", 2*tp/(2*tp+fp+fn))
</code></pre></div></div>

<p>最终模型预测的准确率在50%左右</p>
:ET