I"²!<p>æ€»ç»“è‡ª</p>

<p>https://isocpp.org/</p>

<p>https://changkun.de/modern-cpp/zh-cn</p>

<h1 id="c-11">C++ 11</h1>

<h2 id="general-features">General Features</h2>

<h3 id="auto">auto</h3>

<p>autoå…³é”®å­—ç”¨äºåœ¨å˜é‡åˆå§‹åŒ–æ—¶æ¨æ–­å˜é‡çš„ç±»å‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

// in c++98
template&lt;class T&gt; void printall(const vector&lt;T&gt;&amp; v)
{
    for (typename vector&lt;T&gt;::const_iterator p = v.begin(); p!=v.end(); ++p)
        cout &lt;&lt; *p &lt;&lt; "\n";
}
// in c++11
template&lt;class T&gt; void printall(const vector&lt;T&gt;&amp; v)
{
    for (auto p = v.begin(); p!=v.end(); ++p)
        cout &lt;&lt; *p &lt;&lt; "\n";
}
</code></pre></div></div>
<h3 id="decltype">decltype</h3>

<p>decltype(E) ä»£è¡¨è¡¨è¾¾å¼ E çš„ç±»å‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

void f(const vector&lt;int&gt;&amp; a, vector&lt;float&gt;&amp; b)
{
    typedef decltype(a[0]*b[0]) Tmp;
    for (int i=0; i&lt;b.size(); ++i) {
        Tmp* p = new Tmp(a[i]*b[i]);
        // ...
    }
    // ...
}
</code></pre></div></div>

<blockquote>
  <p>Note: Prefer just using auto when you just need the type for a variable that you are about to initialize. You really need decltype if you need a type for something that is not a variable, such as a return type.</p>
</blockquote>

<h3 id="range-for-statement">Range-for statement</h3>

<p>ç”¨range-based for loopå’Œautoæ›¿ä»£åŸç”ŸCä¸­çš„forè¯­å¥</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

void f(vector&lt;double&gt;&amp; v)
{
    for (auto x : v) cout &lt;&lt; x &lt;&lt; '\n';
    for (auto&amp; x : v) ++x;  // using a reference to allow us to change  the value
}

//x.begin() and x.end stand for the first and last element of container.
</code></pre></div></div>

<h3 id="initializer-lists">Initializer lists</h3>

<p>é™¤éä½ æ‰“ç®—å’ŒC++98ç¼–è¯‘å™¨å…±äº«ä½ çš„ä»£ç ï¼Œå¦åˆ™åº”ä½¿ç”¨initializer_listé‡è½½æ„é€ å‡½æ•°</p>

<h3 id="uniform-initialization-syntax-and-semantics">Uniform initialization syntax and semantics</h3>

<p>C++11ä¸­å…è®¸ç”¨initializer_liståšä¸€åˆ‡åˆå§‹åŒ–å·¥ä½œ</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example 

X x1 = X{1,2}; 
X x2 = {1,2};   // the = is optional
X x3{1,2}; 
X* p = new X{1,2}; 
struct D : X {
    D(int x, int y) :X{x,y} { /* ... */ };
};
struct S {
    int a[3];
    S(int x, int y, int z) :a{x,y,z} { /* ... */ }; // solution to old problem
};
</code></pre></div></div>

<h3 id="lambdas">lambdas</h3>

<p>lambdaè¡¨è¾¾å¼/åŒ¿åå‡½æ•°</p>

<h3 id="noexcept-to-prevent-exception-propagation">noexcept to prevent exception propagation</h3>

<p>åœ¨noexceptå‡½æ•°ä¸­æŠ›å‡ºå¼‚å¸¸ä¼šè°ƒç”¨std::terminate()ç»ˆæ­¢ç¨‹åºï¼Œä¸ºç¼–è¯‘å™¨çš„ä¼˜åŒ–æä¾›äº†æ›´å¤§çš„ç©ºé—´</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//example

constexpr int len_2_constexpr = 1 + 2 + 3;
char arr_4[len_2_constexpr];         // åˆæ³•
</code></pre></div></div>
<h3 id="constexpr">constexpr</h3>

<p>C++11 æä¾›äº† constexpr è®©ç”¨æˆ·æ˜¾å¼çš„å£°æ˜å‡½æ•°æˆ–å¯¹è±¡æ„é€ å‡½æ•°åœ¨ç¼–è¯‘æœŸä¼šæˆä¸ºå¸¸é‡è¡¨è¾¾å¼ï¼Œå¦‚æœç¼–è¯‘å™¨èƒ½å¤Ÿåœ¨ç¼–è¯‘æ—¶å°±æŠŠè¿™äº›è¡¨è¾¾å¼ç›´æ¥ä¼˜åŒ–å¹¶æ¤å…¥åˆ°ç¨‹åºè¿è¡Œæ—¶ï¼Œå°†èƒ½å¢åŠ ç¨‹åºçš„æ€§èƒ½</p>

<h3 id="nullptr--a-null-pointer-literal">nullptr â€“ a null pointer literal</h3>

<p>nullptræ›¿ä»£NULLé¿å…æ­§ä¹‰</p>

<h3 id="inline-namespaces">inline namespaces</h3>

<p>å†…è”å‘½åç©ºé—´å£°æ˜ä¹‹åï¼Œå°±å¯ä»¥åœ¨å¤–å±‚å‘½åç©ºé—´ä¸é€‚ç”¨å‰ç¼€è€Œç›´æ¥ä½¿ç”¨å®ƒä»¬äº†</p>

<p>see: https://blog.csdn.net/craftsman1970/article/details/82872497</p>

<h3 id="rvalue-references-and-move-semantics">Rvalue references and move semantics</h3>

<p>å·¦å€¼æ˜¯è¡¨è¾¾å¼ï¼ˆä¸ä¸€å®šæ˜¯èµ‹å€¼è¡¨è¾¾å¼ï¼‰åä¾ç„¶å­˜åœ¨çš„æŒä¹…å¯¹è±¡ã€‚
å³å€¼æ˜¯æŒ‡è¡¨è¾¾å¼ç»“æŸåå°±ä¸å†å­˜åœ¨çš„ä¸´æ—¶å¯¹è±¡ã€‚</p>

<p><strong>å³å€¼å¼•ç”¨ï¼Œç§»åŠ¨è¯­ä¹‰</strong></p>

<p>è€ƒè™‘C++98ä¸­å¦‚ä¸‹æƒ…å†µ</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;int&gt; foo() {
    std::vector&lt;int&gt; temp = {1, 2, 3, 4};
    return temp;
}

std::vector&lt;int&gt; v = foo();
</code></pre></div></div>

<p>è°ƒç”¨foo()åï¼Œè°ƒç”¨æ‹·è´æ„é€ å‡½æ•°å°†è¿”å›å€¼tempèµ‹ç»™vï¼Œå†è°ƒç”¨tempçš„ææ„å‡½æ•°ï¼Œé€ æˆäº†ä¸å¿…è¦çš„å¼€é”€</p>

<p>åœ¨ C++11 ä¹‹åï¼Œç¼–è¯‘å™¨ä¸ºæˆ‘ä»¬åšäº†ä¸€äº›å·¥ä½œï¼Œæ­¤å¤„çš„å·¦å€¼ temp ä¼šè¢«è¿›è¡Œæ­¤éšå¼å³å€¼è½¬æ¢ï¼Œ ç­‰ä»·äº static_cast&lt;std::vector<int> &amp;&amp;&gt;(temp)ï¼Œè¿›è€Œæ­¤å¤„çš„ v ä¼šå°† foo å±€éƒ¨è¿”å›çš„å€¼è¿›è¡Œç§»åŠ¨ï¼Œè¢« vector çš„**ç§»åŠ¨æ„é€ å‡½æ•°**å¼•ç”¨ï¼Œä»è€Œå»¶é•¿ç”Ÿå‘½å‘¨æœŸï¼Œå¹¶å°†è¿™ä¸ªå³å€¼ä¸­çš„æŒ‡é’ˆæ‹¿åˆ°ï¼Œä¿å­˜åˆ°äº† obj ä¸­ï¼Œè€Œå°†äº¡å€¼çš„æŒ‡é’ˆè¢«è®¾ç½®ä¸º nullptrï¼Œé˜²æ­¢äº†è¿™å—å†…å­˜åŒºåŸŸè¢«é”€æ¯ã€‚</int></p>

<p>ä»è€Œé¿å…äº†æ— æ„ä¹‰çš„æ‹·è´æ„é€ ï¼ŒåŠ å¼ºäº†æ€§èƒ½ã€‚</p>

<p>C++11 æä¾›äº† std::move è¿™ä¸ªæ–¹æ³•å°†å·¦å€¼å‚æ•°æ— æ¡ä»¶çš„è½¬æ¢ä¸ºå³å€¼</p>

<h2 id="class-features">Class Features</h2>

<h3 id="defaultdeleteå…³é”®å­—">default,deleteå…³é”®å­—</h3>

<p>defaultï¼šä½¿ç”¨é»˜è®¤æ„é€ /ææ„/æ‹·è´æ„é€ å‡½æ•°
deleteï¼šç¦ç”¨æ„é€ /ææ„/æ‹·è´æ„é€ å‡½æ•°</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example : default

class X1 {
    // ...
    X1&amp; operator=(const X1&amp;) = default;    // default copying
    X1(const X1&amp;) = default;
};
// example : delete

class X2 {
    // ...
    X2&amp; operator=(const X2&amp;) = delete;    // Disallow copying
    X2(const X2&amp;) = delete;
};

</code></pre></div></div>

<h3 id="ç§»åŠ¨æ‹·è´ç§»åŠ¨æ„é€ ">ç§»åŠ¨æ‹·è´ï¼Œç§»åŠ¨æ„é€ </h3>

<p>æ¥å—å³å€¼æ—¶è°ƒç”¨ç§»åŠ¨æ‹·è´ï¼Œç§»åŠ¨æ„é€ å‡½æ•°
æ¥å—å·¦å€¼æ—¶è°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ï¼Œæ‹·è´æ„é€ è¿ç®—ç¬¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class X1 {
    // ...
    X1&amp; operator=(X1&amp;&amp;); // move assignment
}

class X2 {
    // ...
    X2&amp; operator=(X2&amp;&amp;); // move constructor
}
</code></pre></div></div>

<h3 id="å§”æ‰˜æ„é€ ">å§”æ‰˜æ„é€ </h3>

<p>æ„é€ å‡½æ•°å¯ä»¥ä»¥åˆå§‹åŒ–åˆ—è¡¨çš„æ–¹å¼è°ƒç”¨å…¶ä»–æ„é€ å‡½æ•°</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

class X {
    int a;
public:
    X(int x) { if (0&lt;x &amp;&amp; x&lt;=max) a=x; else throw bad_X(x); }
    X() :X{42} { }
    X(string s) :X{lexical_cast&lt;int&gt;(s)} { }
    // ...
};
</code></pre></div></div>

<h3 id="ç»§æ‰¿æ„é€ ">ç»§æ‰¿æ„é€ </h3>

<h3 id="overrideå…³é”®å­—">overrideå…³é”®å­—</h3>

<h3 id="finalå…³é”®å­—">finalå…³é”®å­—</h3>

<p>å†ç±»/å‡½æ•°ååŠ finalå…³é”®å­—ç¦æ­¢é‡è½½</p>

<h3 id="explicit-conversion-operators">Explicit conversion operators</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

struct S { S(int) { } };

struct SS {
    int m;
    SS(int x) :m(x) { }
    explicit operator S() { return S(m); }  // because S don't have S(SS)
};

SS ss(1);
S s1 = ss;  // error; like an explicit constructor
S s2(ss);   // ok ; like an explicit constructor
void f(S); 
f(ss);      // error; like an explicit constructor

</code></pre></div></div>

<h3 id="in-class-member-initializers">In-class member initializers</h3>

<p>C++98åªå…è®¸static const intç±»å‹å˜é‡ç±»å†…åˆå§‹åŒ–
C++11å…è®¸æ‰€æœ‰æˆå‘˜ä»¥åˆå§‹åŒ–åˆ—è¡¨çš„æ–¹å¼è¿›è¡Œåˆå§‹åŒ–</p>

<h2 id="other-types">Other Types</h2>

<h3 id="enum-class">enum class</h3>

<p>enumçš„é—®é¢˜</p>
<ul>
  <li>Conventional enums implicitly convert to an integer, causing errors when someone does not want an enumeration to act as an integer.</li>
  <li>Conventional enums export their enumerators to the surrounding scope, causing name clashes.</li>
  <li>The underlying type of an enum cannot be specified, causing confusion, compatibility problems, and makes forward declaration impossible.</li>
</ul>

<h3 id="long-long--a-longer-integer">long long â€“ a longer integer</h3>

<p>64ä½int</p>

<h3 id="generalized-pods">Generalized PODs</h3>

<h2 id="templates">templates</h2>

<h2 id="misc">Misc</h2>
<p>__cplusplusä»£è¡¨C++  201103L</p>

<hr />

<h1 id="c14">C++14</h1>

<p>C++14 å¼€å§‹ï¼Œconstexpr å‡½æ•°å¯ä»¥åœ¨å†…éƒ¨ä½¿ç”¨å±€éƒ¨å˜é‡ã€å¾ªç¯å’Œåˆ†æ”¯ç­‰ç®€å•è¯­å¥</p>
:ET