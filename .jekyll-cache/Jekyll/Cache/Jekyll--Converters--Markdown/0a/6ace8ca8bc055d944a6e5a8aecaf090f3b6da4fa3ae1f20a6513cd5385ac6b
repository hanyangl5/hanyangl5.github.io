I"æ<p>ç”±ç¨‹åºäº§ç”Ÿå™ªå£°çš„æ–¹æ³•å¤§è‡´å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼š</p>

<ul>
  <li>
    <p>åŸºäºæ™¶æ ¼çš„æ–¹æ³•ï¼ˆLattice basedï¼‰åˆå¯ç»†åˆ†ä¸ºä¸¤ç§ï¼š
  ç¬¬ä¸€ç§æ˜¯æ¢¯åº¦å™ªå£°ï¼ˆGradient noiseï¼‰ï¼ŒåŒ…æ‹¬Perlin noiseï¼ŒSimplex noiseï¼ŒWavelet noiseç­‰
  ç¬¬äºŒç§æ˜¯Value noiseã€‚</p>
  </li>
  <li>
    <p>åŸºäºç‚¹çš„æ–¹æ³•ï¼ˆPoint basedï¼‰
  Worley noise</p>
  </li>
</ul>

<hr />

<p>ä¸‹å›¾æ˜¯æˆ‘ä»¬å¸¸è§çš„ç™½å™ªå£°å›¾åƒ</p>

<p><img src="https://raytracing.github.io/images/img-2-5-01.jpg" alt="" /></p>

<p>æ¢¯åº¦å™ªå£°äº§ç”Ÿçš„çº¹ç†å…·æœ‰è¿ç»­æ€§ï¼Œå› ä¸ºåœ¨å…¶å™ªå£°ä¸ç›¸é‚»ç‚¹å™ªå£°çš„åŠ æƒæœ‰å…³ï¼Œæ‰€ä»¥ç»å¸¸ç”¨æ¥æ¨¡æ‹Ÿå±±è„‰ã€äº‘æœµç­‰å…·æœ‰è¿ç»­æ€§çš„ç‰©è´¨ï¼Œperlin noiseï¼Œå…¶å®ƒæ¢¯åº¦å™ªå£°è¿˜æœ‰Simplex Noiseå’ŒWavelet Noiseï¼Œå®ƒä»¬ä¹Ÿæ˜¯ç”±Perlin Noiseæ¼”å˜è€Œæ¥</p>

<p>Perlin Noiseè¿”å›å¦‚ä¸‹æ‰€ç¤ºçš„å›¾åƒï¼Œæ˜¯ä¸€ä¸ªå…·æœ‰æ¨¡ç³Šæ•ˆæœçš„å™ªå£°å›¾</p>

<p><img src="https://raytracing.github.io/images/img-2-5-02.jpg" alt="" /></p>

<hr />

<h3 id="ç®—æ³•æ­¥éª¤">ç®—æ³•æ­¥éª¤</h3>

<p>ç”Ÿæˆperlin noiseçš„æ­¥éª¤å¦‚ä¸‹ï¼š</p>

<ul>
  <li>
    <p>ç»™å®šç‚¹è¾“å…¥ç‚¹p</p>
  </li>
  <li>
    <p>å¯¹äºæ¯ä¸€ä¸ªä¸ç‚¹pç›¸é‚»çš„æ–¹æ ¼ç«¯ç‚¹ï¼ˆäºŒç»´çš„å™ªå£°å°±æ˜¯4ä¸ªç‚¹ï¼Œä¸‰ç»´å™ªå£°å°±æ˜¯8ä¸ªç‚¹ï¼‰</p>
  </li>
  <li>
    <p>æŒ‘é€‰ä¸€ä¸ªä¼ªéšæœºæ¢¯åº¦å‘é‡</p>
  </li>
  <li>
    <p>è®¡ç®—éšæœºå‘é‡å’Œè·ç¦»çš„ç‚¹ç§¯</p>
  </li>
  <li>
    <p>æ¯ä¸ªç»´åº¦ä¸Šï¼Œå‡é‡‡ç”¨ç¼“å’Œæ›²çº¿ï¼Œè®¡ç®—å‡ºåŠ æƒå¹³å‡å€¼ï¼Œç¼“å’Œæ›²çº¿å¯ä»¥é€‰ç”¨3<em>t^3-2</em>t^3</p>
  </li>
</ul>

<p>å…·ä½“æ¨å¯¼å¯è§ä¸‹é¢å‡ ç¯‡æ–‡ç« ä»¥åŠpen perlinçš„è®ºæ–‡</p>

<p><a href="https://blog.csdn.net/qq_34302921/article/details/80849139"></a></p>

<p><a href="http://www.twinklingstar.cn/2015/2581/classical-perlin-noise/#2_Perlin"></a></p>

<hr />

<h3 id="perlinh">perlin.h</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static vec3* perlin_generate() {
    vec3 *p = new vec3[256];
    for (int i = 0; i &lt; 256; ++i) {
        double x_random = 2*random_double() - 1;
        double y_random = 2*random_double() - 1;
        double z_random = 2*random_double() - 1;
        p[i] = unit_vector(vec3(x_random, y_random, z_random));
    }
    return p;
}
</code></pre></div></div>

<p>perlin_generateè¿”å›ä¸€ä¸ªé•¿åº¦ä¸º1çš„éšæœºvec3æ•°ç»„</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void permute(int *p, int n) {
    for (int i = n-1; i &gt; 0; i--) {
        int target = int(random_double()*(i+1));
        int tmp = p[i];
        p[i] = p[target];
        p[target] = tmp;
    }
    return;
}
</code></pre></div></div>

<p>æ‰“ä¹±æ•°ç»„pçš„é¡ºåºï¼Œç»æµ‹è¯•ï¼Œstd::random_shuffleä¹Ÿå¯ä»¥è¾¾åˆ°åŒæ ·çš„æ•ˆæœ</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static int* perlin_generate_perm() {
    int * p = new int[256];
    for (int i = 0; i &lt; 256; i++)
        p[i] = i;
    permute(p, 256);
    return p;
}
</code></pre></div></div>

<p>perlin_generate_permè¿”å›ä¸€ä¸ªä¹±åºæ— é‡å¤çš„ä»0~255çš„æ•°ç»„</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inline float perlin_interp(vec3 c[2][2][2], float u, float v, float w) {
    //ç¼“å’Œæ›²çº¿
    float uu = u*u*(3-2*u);
    float vv = v*v*(3-2*v);
    float ww = w*w*(3-2*w);
    float accum = 0;
    for (int i=0; i &lt; 2; i++)
        for (int j=0; j &lt; 2; j++)
            for (int k=0; k &lt; 2; k++) {
                vec3 weight_v(u-i, v-j, w-k);
                //ä¸‰ç»´çº¿æ€§æ’å€¼*æƒé‡*æ¢¯åº¦
                accum += (i*uu + (1-i)*(1-uu))*
                    (j*vv + (1-j)*(1-vv))*
                    (k*ww + (1-k)*(1-ww))*dot(c[i][j][k], weight_v);
            }
    return accum;
}
</code></pre></div></div>

<p>perlinç±»</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class perlin {
    public:
        float noise(const vec3&amp; p) const;
        static vec3 *ranvec;
        static int *perm_x;
        static int *perm_y;
        static int *perm_z;
};

vec3* perlin::ranvec = perlin_generate();//éšæœºå‘é‡
int *perlin::perm_x = perlin_generate_perm();//éšæœºæ•°ç»„
int *perlin::perm_y = perlin_generate_perm();//éšæœºæ•°ç»„
int *perlin::perm_z = perlin_generate_perm();//éšæœºæ•°ç»„

float perlin::noise(const vec3&amp; p) const {
    float u = p.x() - floor(p.x());
    float v = p.y() - floor(p.y());
    float w = p.z() - floor(p.z());

    int i = floor(p.x());
    int j = floor(p.y());
    int k = floor(p.z());

    vec3 c[2][2][2];
    //æŒ‘é€‰pä¸´è¿‘8ä¸ªç‚¹çš„éšæœºå‘é‡
    for (int di=0; di &lt; 2; di++)
        for (int dj=0; dj &lt; 2; dj++)
            for (int dk=0; dk &lt; 2; dk++)
                //åªä¿ç•™å8ä½
                c[di][dj][dk] = ranvec[perm_x[(i+di) &amp; 255] ^ perm_y[(j+dj) &amp; 255] ^ perm_z[(k+dk) &amp; 255] ];

    return perlin_interp(c, u, v, w);
}
</code></pre></div></div>

<p>perlin_noiseæè´¨</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class noise_texture : public texture {
    public:
        noise_texture() {}
        noise_texture(float sc) : scale(sc) {}
        virtual vec3 value(float u, float v, const vec3&amp; p) const {
            return vec3(1,1,1) * noise.noise(scale*p);
        }

        perlin noise;
        float scale;
};
</code></pre></div></div>

<p>noise_textureæ¥å—ä¸€ä¸ªscaleå€¼ï¼Œscaleè¶Šå¤§ï¼Œå™ªå£°çº¹ç†è¶Šå¯†</p>

<hr />

<h3 id="test">test</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hittable *two_perlin_spheres() {
    texture* pertext = new noise_texture(10);
    texture* simple=new constant_texture(vec3(0.0,0.0,0.0));
    hittable **list = new hittable*[2];
    list[0] = new sphere(vec3(0,-1000, 0), 1000, new lambertian(pertext));
    list[1] = new sphere(vec3(0, 2, 0), 1, new lambertian(pertext));
    return new hittable_list(list, 2);
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vec3 lookfrom(13,4,3);
vec3 lookat(0,2,0);
float dist_to_focus = 10.0;
float aperture = 0.0;
float vfov = 20.0;

camera cam(lookfrom, lookat, vec3(0,1,0), vfov, float(nx)/float(ny),aperture, dist_to_focus, 0.0, 1.0);
hittable* world=two_perlin_spheres();
</code></pre></div></div>

<p>æ¸²æŸ“å‡ºçš„å›¾ç‰‡å¦‚ä¸‹</p>

<p><img src="https://pic.downk.cc/item/5e3036a92fb38b8c3ccb988b.png" alt="" /></p>

<hr />

<h3 id="turb">turb</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>float turb(const vec3 &amp;p, int depth = 7) const {
    float accum = 0;
    vec3 temp_p = p;
    float weight = 1.0;

    for (int i = 0; i &lt; depth; i++) {
      accum += weight * noise(temp_p);
      weight *= 0.5;
      temp_p *= 2;
    }
    return fabs(accum);
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class noise_texture : public texture {
    public:
        noise_texture() {}
        noise_texture(float sc) : scale(sc) {}
        virtual vec3 value(float u, float v, const vec3&amp; p) const {
            return vec3(1,1,1) * 0.5 * (1 + sin(scale*p.z() + 10*noise.turb(p)));
        }
        perlin noise;
        float scale;
};
</code></pre></div></div>

<p>åŠ ä¸Šturbulenceåæ¸²æŸ“å‡ºçš„å¤§ç†çŸ³æè´¨</p>

<p><img src="https://pic.downk.cc/item/5e303a112fb38b8c3ccbe11a.png" alt="" /></p>
:ET