I"j*<p>总结自</p>

<p>https://isocpp.org/</p>

<p>https://changkun.de/modern-cpp/zh-cn</p>

<h1 id="c-11">C++ 11</h1>

<h2 id="general-features">General Features</h2>

<h3 id="auto">auto</h3>

<p>auto关键字用于在变量初始化时推断变量的类型</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

// in c++98
template&lt;class T&gt; void printall(const vector&lt;T&gt;&amp; v)
{
    for (typename vector&lt;T&gt;::const_iterator p = v.begin(); p!=v.end(); ++p)
        cout &lt;&lt; *p &lt;&lt; "\n";
}
// in c++11
template&lt;class T&gt; void printall(const vector&lt;T&gt;&amp; v)
{
    for (auto p = v.begin(); p!=v.end(); ++p)
        cout &lt;&lt; *p &lt;&lt; "\n";
}
</code></pre></div></div>
<h3 id="decltype">decltype</h3>

<p>decltype(E) 代表表达式 E 的类型</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

void f(const vector&lt;int&gt;&amp; a, vector&lt;float&gt;&amp; b)
{
    typedef decltype(a[0]*b[0]) Tmp;
    for (int i=0; i&lt;b.size(); ++i) {
        Tmp* p = new Tmp(a[i]*b[i]);
        // ...
    }
    // ...
}
</code></pre></div></div>

<blockquote>
  <p>Note: Prefer just using auto when you just need the type for a variable that you are about to initialize. You really need decltype if you need a type for something that is not a variable, such as a return type.</p>
</blockquote>

<h3 id="range-for-statement">Range-for statement</h3>

<p>用range-based for loop和auto替代原生C中的for语句</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

void f(vector&lt;double&gt;&amp; v)
{
    for (auto x : v) cout &lt;&lt; x &lt;&lt; '\n';
    for (auto&amp; x : v) ++x;  // using a reference to allow us to change  the value
}

//x.begin() and x.end stand for the first and last element of container.
</code></pre></div></div>

<h3 id="initializer-lists">Initializer lists</h3>

<p>除非你打算和C++98编译器共享你的代码，否则应使用initializer_list重载构造函数</p>

<h3 id="uniform-initialization-syntax-and-semantics">Uniform initialization syntax and semantics</h3>

<p>C++11中允许用initializer_list做一切初始化工作</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example 

X x1 = X{1,2}; 
X x2 = {1,2};   // the = is optional
X x3{1,2}; 
X* p = new X{1,2}; 
struct D : X {
    D(int x, int y) :X{x,y} { /* ... */ };
};
struct S {
    int a[3];
    S(int x, int y, int z) :a{x,y,z} { /* ... */ }; // solution to old problem
};
</code></pre></div></div>

<h3 id="lambdas">lambdas</h3>

<p>lambda表达式/匿名函数</p>

<h3 id="noexcept-to-prevent-exception-propagation">noexcept to prevent exception propagation</h3>

<p>在noexcept函数中抛出异常会调用std::terminate()终止程序，为编译器的优化提供了更大的空间</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//example

constexpr int len_2_constexpr = 1 + 2 + 3;
char arr_4[len_2_constexpr];         // 合法
</code></pre></div></div>
<h3 id="constexpr">constexpr</h3>

<p>C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能</p>

<h3 id="nullptr--a-null-pointer-literal">nullptr – a null pointer literal</h3>

<p>nullptr替代NULL避免歧义</p>

<h3 id="inline-namespaces">inline namespaces</h3>

<p>内联命名空间声明之后，就可以在外层命名空间不适用前缀而直接使用它们了</p>

<p>see: https://blog.csdn.net/craftsman1970/article/details/82872497</p>

<h3 id="rvalue-references-and-move-semantics">Rvalue references and move semantics</h3>

<p>左值是表达式（不一定是赋值表达式）后依然存在的持久对象。
右值是指表达式结束后就不再存在的临时对象。</p>

<p><strong>右值引用，移动语义</strong></p>

<p>考虑C++98中如下情况</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;int&gt; foo() {
    std::vector&lt;int&gt; temp = {1, 2, 3, 4};
    return temp;
}

std::vector&lt;int&gt; v = foo();
</code></pre></div></div>

<p>调用foo()后，调用拷贝构造函数将返回值temp赋给v，再调用temp的析构函数，造成了不必要的开销</p>

<p>在 C++11 之后，编译器为我们做了一些工作，此处的左值 temp 会被进行此隐式右值转换， 等价于 static_cast&lt;std::vector<int> &amp;&amp;&gt;(temp)，进而此处的 v 会将 foo 局部返回的值进行移动，被 vector 的**移动构造函数**引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。</int></p>

<p>从而避免了无意义的拷贝构造，加强了性能。</p>

<p>C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值</p>

<h2 id="class-features">Class Features</h2>

<h3 id="defaultdelete关键字">default,delete关键字</h3>

<p>default：使用默认构造/析构/拷贝构造函数
delete：禁用构造/析构/拷贝构造函数</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example : default

class X1 {
    // ...
    X1&amp; operator=(const X1&amp;) = default;    // default copying
    X1(const X1&amp;) = default;
};
// example : delete

class X2 {
    // ...
    X2&amp; operator=(const X2&amp;) = delete;    // Disallow copying
    X2(const X2&amp;) = delete;
};

</code></pre></div></div>

<h3 id="移动拷贝移动构造">移动拷贝，移动构造</h3>

<p>接受右值时调用移动拷贝，移动构造函数
接受左值时调用拷贝构造函数，拷贝构造运算符</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class X1 {
    // ...
    X1&amp; operator=(X1&amp;&amp;); // move assignment
}

class X2 {
    // ...
    X2&amp; operator=(X2&amp;&amp;); // move constructor
}
</code></pre></div></div>

<h3 id="委托构造">委托构造</h3>

<p>构造函数可以以初始化列表的方式调用其他构造函数</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

class X {
    int a;
public:
    X(int x) { if (0&lt;x &amp;&amp; x&lt;=max) a=x; else throw bad_X(x); }
    X() :X{42} { }
    X(string s) :X{lexical_cast&lt;int&gt;(s)} { }
    // ...
};
</code></pre></div></div>

<h3 id="继承构造">继承构造</h3>

<h3 id="override关键字">override关键字</h3>

<h3 id="final关键字">final关键字</h3>

<p>再类/函数后加final关键字禁止重载</p>

<h3 id="explicit-conversion-operators">Explicit conversion operators</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example

struct S { S(int) { } };

struct SS {
    int m;
    SS(int x) :m(x) { }
    explicit operator S() { return S(m); }  // because S don't have S(SS)
};

SS ss(1);
S s1 = ss;  // error; like an explicit constructor
S s2(ss);   // ok ; like an explicit constructor
void f(S); 
f(ss);      // error; like an explicit constructor

</code></pre></div></div>

<h3 id="in-class-member-initializers">In-class member initializers</h3>

<p>C++98只允许static const int类型变量类内初始化
C++11允许所有成员以初始化列表的方式进行初始化</p>

<h2 id="other-types">Other Types</h2>

<h3 id="enum-class">enum class</h3>

<p>enum的问题</p>
<ul>
  <li>Conventional enums implicitly convert to an integer, causing errors when someone does not want an enumeration to act as an integer.</li>
  <li>Conventional enums export their enumerators to the surrounding scope, causing name clashes.</li>
  <li>The underlying type of an enum cannot be specified, causing confusion, compatibility problems, and makes forward declaration impossible.</li>
</ul>

<h3 id="long-long--a-longer-integer">long long – a longer integer</h3>

<p>64位int</p>

<!-- ## templates
### Template aliases
### Variadic templates -->

<h2 id="杂项">杂项</h2>

<h3 id="__cpluscplus">__cpluscplus</h3>

<p>c++11后<code class="language-plaintext highlighter-rouge">__cplusplus</code>代表 <em>201103L</em></p>

<h3 id="preventing-narrowing">Preventing narrowing</h3>

<p>C++11中用<code class="language-plaintext highlighter-rouge">{}</code>初始化可以避免narrow的问题</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example: C++98

int x = 7.3;        // Ouch!
void f(int);
f(7.3);         // Ouch!
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// example: C++11

int x0 {7.3};   // error: narrowing
int x1 = {7.3}; // error: narrowing
double d = 7;
int x2{d};      // error: narrowing (double to int)
char x3{7};     // ok: even though 7 is an int, this is not narrowing
vector&lt;int&gt; vi = { 1, 2.3, 4, 5.6 };    // error: double to int narrowing
</code></pre></div></div>
<h3 id="right-angle-brackets">Right-angle brackets</h3>

<p>解决了右尖括号编译问题</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list&lt;vector&lt;string&gt;&gt; lvs;
</code></pre></div></div>

<h3 id="static_assert">static_assert</h3>

<p>编译期的<code class="language-plaintext highlighter-rouge">assert</code>，不会造成任何运行期性能损失</p>

<h3 id="raw-string-literals">Raw string literals</h3>

<h3 id="alignment">Alignment</h3>

<p>字节对齐，不同编译器的方式不同</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct alignas(8) X
{
    char a;
    int  b;
    double c;
};
</code></pre></div></div>
<h2 id="libiary">Libiary</h2>

<h3 id="智能指针">智能指针</h3>

<p>std::shared_ptr
std::unique_ptr
std::weak_ptr</p>

<h3 id="stdarray">std::array</h3>
<p>替代原生数组</p>
<h3 id="function--bind">function &amp; bind</h3>
<h3 id="type-traits">type traits</h3>
<h3 id="garbage-collection-abi">Garbage collection ABI</h3>
<h3 id="tuple">tuple</h3>
<h3 id="random-number-generation">Random number generation</h3>
<h3 id="scoped-allocators">Scoped allocators</h3>
<hr />

<h1 id="c14">C++14</h1>

<h2 id="general-features-1">General Features</h2>

<p>Binary literals
C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句</p>
:ET