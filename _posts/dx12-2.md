---
layout: post
title: Direct3D 12 工作流程
date: 2020-09-29
---



###  Direct3D 12 工作流程

- Initialize
- Repeat
  - Update
  - Render
- Destroy


Initialize部分

- Enable the debug layer.
- Create the device.
- Create the command queue.
- Create the swap chain.
- Create a render target view (RTV) descriptor heap.
- Create frame resources (a render target view for each frame).
- Create a command allocator.
- Create an empty root signature.
- Compile the shaders.
- Create the vertex input layout.
- Create a pipeline state object description, then create the object.
- Create the command list.
- Close the command list.
- Create and load the vertex buffers.
- Create the vertex buffer views.
- Create a fence.
- Create an event handle.
- Wait for the GPU to finish.

Update部分

更新constant，vertex，index buffers等

Render部分

- Populate the command list.
  - Reset the command list allocator.
Reset the command list.
Set the graphics root signature.
Set the viewport and scissor rectangles.
Set a resource barrier, indicating the back buffer is to be used as a render target.
  - Record commands into the command list.
  - Indicate the back buffer will be used to present after the command list has executed.
  - Close the command list to further recording.
- Execute the command list.
- Present the frame.
- Wait for the GPU to finish.

Destroy部分

- Wait for the GPU to finish.
- Close the event handle.

## 名词解释


### The Device

device由ID3D12Device接口表示，代表一个虚拟的显示适配器，用于创建command allocators, command lists, command queues, fences, resources, pipeline state objects, heaps, root signatures, samplers, 等对象.

我们用IDXGIFactory::EnumAdapters遍历硬件设备（显卡），检查设备对dx12的支持，用 D3D12CreateDevice()创建device对象

### Command Queues

![](http://www.braynzarsoft.net/image/100207)

Command Queue本质上是一个环形的缓冲区 CPU通过command list将命令传输到cmd queue，由cmd queue执行命令

command queue对象由ID3D12CommandQueue表示，用CreateCommandQueue创建对象

**Code Sample**

~~~
ComPtr<ID3D12CommandQueue> m_commandQueue;
~~~
~~~
// Describe and create the command queue.
D3D12_COMMAND_QUEUE_DESC queueDesc = {};
queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;

ThrowIfFailed(m_device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&m_commandQueue)));
~~~
D3D12_COMMAND_QUEUE_DESC是用于描述所创建的cmdqueue的结构体，dx12中许多对象的创建都使用此方式，后面将不再赘述

~~~
typedef struct D3D12_COMMAND_QUEUE_DESC {
  D3D12_COMMAND_LIST_TYPE   Type;//cmdqueue的种类
  INT                       Priority;//cmdlist的优先级，多个cmdlist不同优先级
  D3D12_COMMAND_QUEUE_FLAGS Flags;
  UINT                      NodeMask;
} D3D12_COMMAND_QUEUE_DESC;
~~~

cmdqueue的种类
~~~
typedef enum D3D12_COMMAND_LIST_TYPE {
  D3D12_COMMAND_LIST_TYPE_DIRECT,//接受任何命令
  D3D12_COMMAND_LIST_TYPE_BUNDLE,//用于bundle cmdlist，more efficient
  D3D12_COMMAND_LIST_TYPE_COMPUTE,//接受compute and copy相关命令
  D3D12_COMMAND_LIST_TYPE_COPY,//只接受copycmd
  D3D12_COMMAND_LIST_TYPE_VIDEO_DECODE,
  D3D12_COMMAND_LIST_TYPE_VIDEO_PROCESS,
  D3D12_COMMAND_LIST_TYPE_VIDEO_ENCODE
} ;
~~~
### Command Lists & Command Allocators

![](http://www.braynzarsoft.net/image/100206)

cmdlist->reset()
将cmdlist切换为记录状态
cmdlist->close
停止记录

ID3D12CommandQueue::ExecuteCommandLists
将cmdlist中的命令添加到cmdqueue中，实则是添加的cmdalloc中命令的的引用

cmdalloc是cmdlist中命令在gpu中的存储位置，类型需与cmdlist一致


我们可以创建多个cmdlist关联与同一个cmdallocator，但同一时间在record的cmdlist不能超过一个

在gpu执行完cmdalloc中的命令后，调用
cmdalloc->reset，将gpu中内存reset
cmdlist->reset，

Example Code
~~~
ThrowIfFailed(m_device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&m_commandAllocator)));
// Create the command list.
ThrowIfFailed(m_device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, m_commandAllocator.Get(), nullptr, IID_PPV_ARGS(&m_commandList)));


ThrowIfFailed(m_commandList->Close());//cmdlist创建时默认是record状态
~~~

### Pipeline State Objects

由ID3D12PipelineState表示, 由CreateGraphicsPipelineState() 创建

pso对象由 D3D12_GRAPHICS_PIPELINE_STATE_DESC描述，用于设置管线的信息
~~~
typedef struct D3D12_GRAPHICS_PIPELINE_STATE_DESC {
  ID3D12RootSignature                *pRootSignature;
  D3D12_SHADER_BYTECODE              VS;
  D3D12_SHADER_BYTECODE              PS;
  D3D12_SHADER_BYTECODE              DS;
  D3D12_SHADER_BYTECODE              HS;
  D3D12_SHADER_BYTECODE              GS;
  D3D12_STREAM_OUTPUT_DESC           StreamOutput;
  D3D12_BLEND_DESC                   BlendState;
  UINT                               SampleMask;
  D3D12_RASTERIZER_DESC              RasterizerState;
  D3D12_DEPTH_STENCIL_DESC           DepthStencilState;
  D3D12_INPUT_LAYOUT_DESC            InputLayout;
  D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue;
  D3D12_PRIMITIVE_TOPOLOGY_TYPE      PrimitiveTopologyType;
  UINT                               NumRenderTargets;
  DXGI_FORMAT                        RTVFormats[8];
  DXGI_FORMAT                        DSVFormat;
  DXGI_SAMPLE_DESC                   SampleDesc;
  UINT                               NodeMask;
  D3D12_CACHED_PIPELINE_STATE        CachedPSO;
  D3D12_PIPELINE_STATE_FLAGS         Flags;
} D3D12_GRAPHICS_PIPELINE_STATE_DESC;
~~~

还有一些信息需要在pso外设置，如

| State                                                           | Method                                                                                                                                                    |
| --------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Resource bindings                                               | IASetIndexBuffer，IASetVertexBuffers，SOSetTargets，OMSetRenderTargets，SetDescriptorHeaps，All SetGraphicsRoot... methods，All SetComputeRoot... methods |
| Viewports                                                       | RSSetViewports                                                                                                                                            |
| Scissor rects                                                   | RSSetScissorRects                                                                                                                                         |
| Blend factor                                                    | OMSetBlendFactor                                                                                                                                          |
| The depth stencil reference value                               | OMSetStencilRef                                                                                                                                           |
| The input-assembler primitive topology order and adjacency type | IASetPrimitiveTopology                                                                                                                                    |

### Resources

resources即我们场景的信息，包括顶点，索引，材质

Resource References/Views
- Constant buffer view (CBV)
- Unordered access view (UAV)
- Shader resource view (SRV)
- Samplers
- Render Target View (RTV)
- Depth Stencil View (DSV)
- Index Buffer View (IBV)
- Vertex Buffer View (VBV)
- Stream Output View (SOV)

### Descriptors (Resource Views)

![](http://www.braynzarsoft.net/image/100208)
descripter 是告诉shader如何查找信息的structure

descripter 位于descripterheap中

### Descriptor Tables
CBV's, UAV's, SRV's and Samplers are stored in descriptor heaps and can be referenced by descriptors by shaders.

RTV's, DSV's, IBV's, VBV's and SOV's are not referenced through descriptor tables, but instead bound directly to the pipeline. The MSDN docs are a little bit confusing on a part of this, and so to tell the truth, i'm not completely sure about this, but MSDN says that these are not stored in descriptor heaps, but thats not completely true for RTV's, DSV's and SOV's, since you need to create a heap and descriptors for them. As far as I understand, there is no other way to create them.


### Descriptor Heaps

resource存贮的地方
cbv，uav，srv，samplers是shader visable的

### Root Signatures
### Resource Barriers

用于改变resource的状态


### Fences and Fence Events
### Overview of Application Flow Control for Direct3D 12
### Multithreading in Direct3D 12

#### resource heap
 与descheap不同，resourceheap保存了资源的数据，储存在cpu/gpu上

### default heap

cpu无权限，shader访问效率高

### upload heap
cpu->gpu
cpu 写权限，gpu读权限
cmdlist通过updatesubresource将uploadheap中资源上传gpu中的defaultheap中

通常是vertexbuferr的储存处


![](interface-hierarchy.png)
![](http://www.braynzarsoft.net/image/100204)


### Details

接下俩我将依照HelloTriangle注意分析这些代码的含义和作用。

![](https://pic.downk.cc/item/5f734358160a154a678d363f.png)


### Ref

https://docs.microsoft.com/zh-cn/windows/win32/direct3d12/what-is-directx-12-