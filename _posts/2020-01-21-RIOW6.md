---
layout: post
title: Ray Tracing in One Weekend Summary VI - Materials
date: 2020-01-20

---

#材质

---

### 材质类

~~~
class material{
public:
    virtual bool scatter(
        const ray& r_in,
        const hit_record& rec,
        vec3& attenuation,
        ray& scattered) const = 0;
};
~~~

scatter函数接受一条光线r_in，碰撞记录rec，衰减attenuation，和散射后的光线scattered

同时要以下代码中稍做修改

sphere.h

~~~
#ifndef SPHEREH
#define SPHEREH

#include "hittable.h"

class sphere: public hittable  {
    public:
        sphere() {}
        sphere(vec3 cen, float r, material *m) : center(cen), radius(r), mat_ptr(m)  {};
        virtual bool hit(const ray& r, float tmin, float tmax, hit_record& rec) const;
        vec3 center;
        float radius;
        material *mat_ptr; /* NEW */
};

bool sphere::hit(const ray& r, float t_min, float t_max, hit_record& rec) const {
    vec3 oc = r.origin() - center;
    float a = dot(r.direction(), r.direction());
    float b = dot(oc, r.direction());
    float c = dot(oc, oc) - radius*radius;
    float discriminant = b*b - a*c;
    if (discriminant > 0) {
        float temp = (-b - sqrt(discriminant))/a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; /* NEW */
            return true;
        }
        temp = (-b + sqrt(discriminant)) / a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.p = r.point_at_parameter(rec.t);
            rec.normal = (rec.p - center) / radius;
            rec.mat_ptr = mat_ptr; /* NEW */
            return true;
        }
    }
    return false;
}
#endif
~~~

hittable.h

~~~
#ifndef HITTABLEH
#define HITTABLEH
#include "ray.h"

class material;

struct hit_record {
    float t;
    vec3 p;
    vec3 normal;
    material *mat_ptr;
};

class hittable  {
    public:
        virtual bool hit(
            const ray& r, float t_min, float t_max, hit_record& rec) const = 0;
};

#endif
~~~

添加类成员mat_ptr用于在球体初始化时指定材质

---

### 漫反射 diffuse

我们用lambert光照模型模拟漫反射，lambert模型用于纯粹的漫反射表面的物体，光源照射到物体表面后，向四面八方反射，产生漫反射效果。

![](https://raytracing.github.io/images/fig-1-08-1.jpg)

如图所示，光线在照射到平面上时反射的方向是随机的

random.h
~~~
vec3 random_in_unit_sphere() {
    vec3 p;
    do {
        p = 2.0*vec3(random_double(), random_double(), random_double()) - vec3(1,1,1);
    } while (p.squared_length() >= 1.0);
    return p;
}
~~~
random_in_unit_sphere生成一个长度为1的随机向量

![](https://raytracing.github.io/images/fig-1-08-2.jpg)

表面法线为 **n**，光线与表面交点 **p**，随机向量 **random**，**p+n+random**就是漫反射的方向

添加material的子类lambertian

~~~
class lambertian : public material {
    public:
        lambertian(const vec3& a) : albedo(a) {}
        virtual bool scatter(const ray& r_in, const hit_record& rec, vec3& attenuation, ray& scattered) const {
            vec3 target = rec.p + rec.normal + random_in_unit_sphere();
            scattered = ray(rec.p, target-rec.p);
            attenuation = albedo;
            return true;
        }
        vec3 albedo;
};
~~~

返回值为true，scattered为反射光线

---

### 高光反射 specular

计算反射方向，数学推导如下

![](https://raytracing.github.io/images/fig-1-09-1.jpg)

我们已知入射方向 **v**，表面法线方向 **n**且长度为1，v在n方向上的投影为 **dot(n,v)**，反射方向即为 **v-2·n·dot(v,n)**

计算反射方向的函数reflect

~~~
vec3 reflect(const vec3& v, const vec3& n) {
    return v - 2*dot(v,n)*n;
}
~~~

添加material的自类metal

~~~
class metal : public material {
    public:
        metal(const vec3& a) : albedo(a) {}
        virtual bool scatter(const ray& r_in, const hit_record& rec,
                             vec3& attenuation, ray& scattered) const {
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            scattered = ray(rec.p, reflected);
            attenuation = albedo;
            return (dot(scattered.direction(), rec.normal) > 0);
        }
        vec3 albedo;
};
~~~

---

修改后的main函数

~~~
#include "svpng.inc"
#include "sphere.h"
#include "hittablelist.h"
#include "camera.h"
#include "random.h"
#include "material.h"
#include<cfloat>

vec3 color(const ray& r, hittable *world, int depth) {
    hit_record rec;
    if (world->hit(r, 0.001, FLT_MAX, rec)) {
        ray scattered;
        vec3 attenuation;
        if (depth < 50 && rec.mat_ptr->scatter(r, rec, attenuation, scattered)) {
            return attenuation*color(scattered, world, depth+1);
        }
        else {
            return vec3(0,0,0);
        }
    }
    else{
    vec3 unit_direction = unit_vector(r.direction());
    float t = 0.5*(unit_direction.y() + 1.0);
    return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);   
    }
}

int main() {

    int nx=600,ny=300,ns=100;
    unsigned char rgb[nx * ny * 3], *p = rgb;
    FILE *fp = fopen("test.png", "wb");

    vec3 lower_left_corner(-2.0, -1.0, -1.0);
    vec3 horizontal(4.0, 0.0, 0.0);
    vec3 vertical(0.0, 2.0, 0.0);
    vec3 origin(0.0, 0.0, 0.0);
    camera cam;
    hittable *list[4];
    list[0] = new sphere(vec3(0,0,-1), 0.5, new lambertian(vec3(0.8, 0.3, 0.3)));
    list[1] = new sphere(vec3(0,-100.5,-1), 100, new lambertian(vec3(0.8, 0.8, 0.0)));
    list[2] = new sphere(vec3(1,0,-1), 0.5, new lambertian(vec3(0.2,0.2,0.8)));
    list[3] = new sphere(vec3(-1,0,-1), 0.5, new metal(vec3(0.8, 0.8, 0.8)));
    hittable *world = new hittable_list(list,4);

    for (int j = ny-1; j >= 0; j--){
        for (int i = 0; i < nx; i++) {
            vec3 col(0,0,0);
            for(int s = 0; s < ns ; s++){
                float u = float(i + random_double()) / float(nx);
                float v = float(j + random_double()) / float(ny);
                ray r = cam.get_ray(u,v);               
                col += color(r, world, 0);           
            }
            col /= float(ns);
            col = vec3( sqrt(col[0]), sqrt(col[1]), sqrt(col[2]) );
            *p++ = int(255.99*col[0]);    /* R */
            *p++ = int(255.99*col[1]);    /* G */
            *p++ = int(255.99*col[2]);    /* B */   
        }
    }
    svpng(fp, nx, ny, rgb, 0);
    fclose(fp); 
    return 0;
}
~~~

在color函数中，depth的值为光线反射的次数

depth=0

![](https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4570.png)

depth=1

![](https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4572.png)

depth=2

![](https://pic.downk.cc/item/5e22f3e52fb38b8c3c5c4574.png)

depth=1000

![](https://pic.downk.cc/item/5e22de9e2fb38b8c3c59f22f.png)

反射次数越多，图像越理想

在迭代过程中，我们假设光线无衰减，attenuation值不变，为物体表面的颜色，因为attenuation<0，反射次数越多，光线颜色的rgb值越来越小，趋近与0，这也是为什么在球体的交界处产生阴影的原因

---

### gamma correction

[一篇对gamma矫正的介绍](https://learnopengl-cn.github.io/05%20Advanced%20Lighting/02%20Gamma%20Correction/#gamma)

人眼对灰阶的感知不是线性的，而是类似1/α的曲线，所以我们生成的图片在某些地方看起来会过暗或过亮

~~~
col = vec3( sqrt(col[0]), sqrt(col[1]), sqrt(col[2]) );
~~~

以上代码的作用是对颜色信息进行一个非线性的映射

---

### shadow acne problem

一些关于此问题的描述和解释

[zhihu](https://www.zhihu.com/question/49090321)

[cause-of-shadow-acne -stackoverflow](https://computergraphics.stackexchange.com/questions/2192/cause-of-shadow-acne)

~~~
if (world->hit(r, 0.001, MAXFLOAT, rec)) {...}
~~~

解决方法是，在上面语句中，将t_min加上一个bias（0.001）

渲染出的图像对比

![](https://pic.downk.cc/item/5e22fcee2fb38b8c3c5d2905.png)

![](https://pic.downk.cc/item/5e22de9e2fb38b8c3c59f22f.png)

---

### fuzz

~~~
class metal : public material {
    public:
        metal(const vec3& a, float f) : albedo(a) { /*NEW*/
            if (f < 1) fuzz = f; else fuzz = 1;
        }

        virtual bool scatter(const ray& r_in, const hit_record& rec,
                             vec3& attenuation, ray& scattered) const {
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            scattered = ray(rec.p, reflected + fuzz*random_in_unit_sphere()); /*NEW*/
            attenuation = albedo;
            return (dot(scattered.direction(), rec.normal) > 0);
        }
        vec3 albedo;
        float fuzz; /*NEW*/
};
~~~

为metal材质添加模糊效果

效果如下：

![](https://pic.downk.cc/item/5e2306652fb38b8c3c5e1354.png)

